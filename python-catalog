

		PYTHON


------------------------------------

	MY TERMINOLOGY

$	: Some command to be used on the Terminal (shell).
>>>	: Some python command.
[]	: Output of a python command.

<description>	: Something to be replaced according to the description.
...				: Possible to repeated pattern indefinitely.

------------------------------------

	JUPYTER/CONDA


- List enviroments:
$ conda env list

- Activate/deactivate enviroment (conda>=4.6):
$ conda activate <enviroment>
$ conda deactivate <enviroment>

$ conda activate udemy

- Open jupyter:
(<env>)$ jupyter notebook
(<env>)$ jupyter notebook <file.ipynb>
(<env>)$ jupyper lab
(<env>)$ jupyper lab <file.ipynb>

- List running Jupyter servers:
(<env>)$ jupyter notebook list

- Terminate Jupyter server:
(<env>)$ jupyter notebook stop
(<env>)$ jupyter notebook stop <port>


- Jupyter shortcuts:

	[shift] + [Enter]	: run cell & go next
	[ctrl] + [Enter]	: run cell & DON'T go next
	[alt] + [Enter]		: run cell & add one cell

	[d] + [d]			: Delete selected cell



MISC

- Finding anaconda's install directory:
$ which conda

- Finding the anaconda's python interpreter (environmental):
(<env>)$ which python


------------------------------------

	MARKDOWN FORMATING (also jupyter)

# Title
**negrito**
*itálico*


------------------------------------

	PYTHON HELP

- Show possible Methods for the object (on jupyter):
<py-object>. + [tab]

- Show Object Documentation (on jupyter):
<py-object>. + [shift] + [tab]

- Show Function Documentation (on jupyter):
<function>() + [shift] + [tab]



- Display the type of a object:
>>> type(<object>)

- Python documentation about object:
>>> help(<py-object>)
>>> print(<py-object>.__doc__)		# equivalent


------------------------------------


	NUMBERS, OPERATORS PREDECEDENCE & RESERVED WORDS

- Order of operations (Operator Precedence):

	**					Exponential.
	~	+	-			Complement (all bits reversed), unary plus and minus.
	*	/	%	//		Multiply, devide, modulo, floor division.
	+	-				Addition and subtraction.
	>>	<<				Right and left bitwise shift.
	&					Bitwise AND.
	^  |				Bitwise XOR and OR.
	<=	<	>	>=		Logical operators.
	=	%=	/=	//=		Assignment operators.
	-=	+=	*=	**=		Assignment operators.
	is	is not			Identity operators.
	in	not in			Membreship operators.
	not	or	and			Logical operators.



NUMBERS

- Hexadecimal:
>>> hex(<number>)

- Binary:
>>> bin(<number>)

- Pow (equivalent to x**y ):
>>> pow(<num>, <num>)

- Pow (equivalent to (x**y)%z ):
>>> pow(<num>, <num>, <num>)

- Absolute Value:
>>> abs(<num>)

- Round with some decimal precision (default=0, also accepts negative):
>>> round(<num>, <precision>)




RESERVED WORDS

	False
	None
	True
	and
	as
	assert
	break
	class
	if
	def
	del
	elif
	else
	except
	return
	for
	from
	global
	try
	import
	in
	is
	lambda
	while
	not
	or
	pass
	raise
	finally
	continue
	nonlocal
	with
	yield




	## Examples ##

		9 | 4
		  |---
Mod ->	1 | 2	<- Floor division

- Division:
>>> 9/4
[]	2.25

- Floor division:
>>> 9//4
[]	2

- Mod:
>>> 9 % 4
[]	1


	## - ##


------------------------------------

	STRINGS

- Simple or double quotation marks can be used to define a String.
- Examples:
>>> ' Eu sou A. '
>>> " I'm A. "
>>> ' Citação: "A". '

- Scape Characters:
	\t		Tab
	\n		New Line


- Print string:
>>> print (<str>)

- Print raw string (any escape sequence interpretation will be ignored):
>>> print (r <str>)

- Size:
>>> len(<string>)

- Access element (index starts on 0):
>>> <string>[<index>]

- Access multiple elements (both optional parameters):
>>> <string>[<included-start>:<excluded-stop>]

- Access elements with some frequency (increment, accepts negative):
>>> <string>[::<step>]

- Concatenate:
>>> <string> + <string>
>>> <string> * <integer-number>

- Print message and return String from console input;
>>> input(<str>)



METHODS

- Make first letter Upper Case:
>>> <string>.capitalize()

- Count how many instances of a character there is:
>>> <string>.count('<char>')

- Find position of first instance of a character:
>>> <string>.find('<char>')

- Make string centered on a specific size using some character:
>>> <string>.center(<size>, '<char>') 

	## Example ##

>>> 'hellooo'.center(20,'~')
[]	'~~~~~~hellooo~~~~~~~'

	## - ##

- Check if there are only AlphaNumeric characters:
>>> <string>.isalnum()

- Check if there are only Alphabetical characters:
>>> <string>.isalpha()

- Make all Lower case:
>>> <string>.lower()

- Check if is all Lower case:
>>> <string>.islower()

- Make all Upper case:
>>> <string>.upper()

- Check if is all Upper case:
>>> <string>.isupper()

- Check if ends with a character:
>>> <string>.endswith('<char>')

- Returns a List using a character as divisor (default=' '):
>>> <string>.split(<divisor>)

- Returns a List including the divisor:
>>> <string>.partition(<divisor>)

- Replace any appearence of a pattern by other:
>>> <string>.replace('<pattern>', '<replacement>')

- Get a String from a List, adding a divisor between each element:
>>> '<divisor>'.join(<list>)






	## Examples ##

>>> someString = 'FUCKING HELP ME'
>>> someString[::2]
[]	FCIGHL E

>>> someString[::-1]
[]	EM PLEH GNIKCUF

>>> (someString[:4] + someString[7]) * 10
[]	FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK 

>>> '! '.join(['FUCKING', 'HELP', 'ME'])
[]	'FUCKING! HELP! ME'

	## - ##


------------------------------------

	STRING FORMATING

OLD FORMATING METHOD

- Formating Strings:

>>> ' %<form-op> ' % <obj>
>>> ' %<form-op>  ...  %<form-op> ' % (<obj>, ..., <obj>)


- Formating Operators:
>>> ' %<padding>.<decimal><format> '

padding :	Minimum padding width.
			Negative number to align to the left, default to right.
			Zero on front to fill remaning space with zeros.

decimal :	Number of decimal cases (default=6).
			Can also be a truncate index for strings.

formats :	Type of format aplied:
	s		- String (or any object with string representation, like numbers).
	d		- Integers (decimal system).
	f		- Floating point numbers.
	x		- Integers in hex representation (lowercase).
	X		- Integers in hex representation (uppercase).





NEW FORMATING METHOD

- New formating method:

>>> ' {} '.format(<obj>)

>>> ' {}  ...  {} '.format(<obj>, ..., <obj>)

>>> ' {<d>[<key>]}  ...  {<d>[<key>]} '.format( <d>=<dict> )



- Formating Operators:
>>> ' {<spec-op>:<form-op>} '

- Specifiers Operators:
	{} - strings will be aplied in the order passed on 'format()'
	{<position>} - positional argument for strings given to 'format()'
	{<key>} - keyword argument; must be defined on 'format()' arguments


- Formating Operators (groups in the order they must be placed or not):

	{:*} - fill remaning space with '*'
	{:0} - fill remaning space with zeros

	{:<} - align left (default for strings)
	{:^} - align center
	{:>} - align right (default for numbers)

	{:-} - only prints sign for negative values (default)
	{:+} - prints '+' for positive values
	{: } - prints ' ' for positive and '-' for negative values

	{:<padding>} - minimum padding width of string format
	{:.<decimal>} - number of decimal cases (default=6), or truncate index for strings
	{:<padding>.<decimal>}

	{:d} - Integers (decimal system)
	{:f} - Floating point numbers
	{:b} - Binary
	{:e} - exponent representation (scientific)
	{:E} - Exponent representation (uppercase E)
	{:%} - faction to percentage


	## Examples ##

>>> ' {2} {0} {3} {1} '.format( 'one', 'three', 'zero', 'two' )
[]	' zero one two three '

>>> B='bee'
>>> C='see'
>>> ' {a} {b} {c} '.format( b=B, c=C, a='eei' )
[]	' eei bee see '

>>> "Binary representation of {0} is {0:b}".format(12)
[]	'Binary representation of 12 is 1100'

	## - ##


- Dynamic Formating:
>>> ' {:{fill}{align}{width}} '.format(<str>, fill='<*/0>', align='< </^/> >', width=<padding>))





- Format unpacking tuple:
>>> ' {}  ...  {} '.format( * <tuple> )

- Format unpacking dictionary:
>>> ' {<key>}  ...  {<key>} '.format( ** <dict> )

- Formating class attributes:
>>> <obj> = <Class>()
>>> ' {anything.<attribute>}  ...  {anything.<attribute>} '.format(anything=<obj>)








OTHER (weird) WAY OF FORMATING

- Format with local variables:

>>> <var> = <value>
>>> f' {<var>} '

>>> <dict> = {...}
>>> f' {<dict>[<key>]}  ...  {<dict>[<key>]} '





	## Examples ##

>>> numerooo = 69.69
>>> otro_num = 27
>>> a = 'Formating operators:\n'
>>> n = 'Número como string: %s\n'
>>> i = 'Inteiro:  %d\n'
>>> f = 'Float(1 decimal):[%12.3f] \n                 [123456789-12]\n'
>>> h = 'Hexadecimal: %X '

>>> print( a, n % numerooo, i % numerooo, f % numerooo, h % otro_num)
[]	Formating operators:
[]
[]	Número como string: 69.69 
[]	Inteiro:  69 
[]	Float(1 decimal):[      69.690] 
[]	                 [123456789-12] 
[]	Hexadecimal: 1B




>>> data = ("John", "Doe", 53.44)
>>> format_string = "Hello %s %s. Your current balance is $%s."
>>> print(format_string % data)




>>> aurelio = 'One: {a}\nTwo: {b}\nThree: {c}'
>>> print(aurelio)
[]	One: {a}
[]	Two: {b}
[]	Three: {c}

>>> aurelio.format(a=1, b='two', c=12.3)
>>> print(aurelio)
[]	One: {a}
[]	Two: {b}
[]	Three: {c}



	## - ##

------------------------------------

	LISTS

- In Python, Lists allow multiple types of data and don't have a fixed size.
- The same ways of accessing and indexing Strings works for Lists.

- Defining a List:
>>> <lsit> = [<element>, ..., <element>]

- Append element to the end of a List:
>>> <list>.append(<element>)

- Add Lists (extend)
>>> <list> + <list>
>>> <list>.extend(<list>)

- Insert a element on a specific index:
>>> <list>.insert(<index>, <element>)

- Remove a element of a index from a list and return it (default-index: -1):
>>> <list>.pop(<index>)

- Remove the first occurrence of a element:
>>> <list>.remove(<element>)

- Check if an element is in a List (boolean):
>>> <element> in <list>




METHODS

- Get the index of a specific element:
>>> <list>.index(<element>)

- Reverse list elements:
>>> <list>.reverse()

- Sort list elements:
>>> <list>.sort()

- Get the list elements sorted (without altering the string):
>>> sorted(<list>)

- Count how many times a element appears:
>>> <list>.count(<element>)





LIST COMPREHENSION

>>> [<element/instruction> for <element> in <iterable>]
>>> [<element/instruction> for <element> in <iterable> if <boolean>]
>>> [<element/instruction> if <boolean> else <element/instruction> for <element> in <iterable>]

>>> [<element/instruction> for <element> in <iterable> for <element> in <iterable> ...]





	## Examples ##

>>> asdf = [1,2,'minha juda']
>>> print(asdf[::-1])
	['minha juda', 2, 1]
>>> print(asdf[-1][::-1])
	aduj ahnim


>>> l_1 = [1,2,3]
>>> l_2 = [4,5,6]
>>> l_3 = [7,8,9]
>>> mat = [l_1, l_2, l_3]

>>> first_col = [row[0] for row in mat]
[]	[1, 4, 7]
>>> first_col = list(list(zip(*mat))[0])
[]	[1, 4, 7]
>>> diag = [mat[ind][ind] for ind in [0,1,2] ]
[]	[1, 5, 9]
>>> diag2 = [mat[ind][2-ind] for ind in [0,1,2] 
[]	[3, 5, 7]
>>> fulllist = [ mat[i][j]  for i in range(len(mat)) for j in range(len(mat[i]))]
[]	[1, 2, 3, 4, 5, 6, 7, 8, 9]





>>> celsius = [0, 10, 15, 20, 30, 50, 100]
>>> fahrenheit = [ temp*(9/5)+32  for temp in  celsius ]
>>> [int(f) for f in fahrenheit]
[]	[32, 50, 59, 68, 86, 122, 212]






- Multiply matrix using list comprehension:

>>> X = [[12,7,3],
>>> 	[4 ,5,6],
>>> 	[7 ,8,9]]

>>> Y = [[5,8,1,2],
>>> 	[6,7,3,0],
>>> 	[4,5,9,1]]

>>> result = [[sum(a*b for a,b in zip(X_row,Y_col)) for Y_col in zip(*Y)] for X_row in X]
>>> for r in result: print(r)
[]	[114, 160, 60, 27]
[]	[74, 97, 73, 14]
[]	[119, 157, 112, 23]



	## - ##

------------------------------------

	DICTIONARIES

- Defining dictionary:
>>> <dict> = {'<key>':<object> , ...}

- Create dictionary using list comprehension:
>>> {<key>: <value> for (<key>, <value>) in <iterable>}

- Accessing elements:
>>> <dict>['key']

- Adding new elements:
>>> <dict>['key'] = <object>



METHODS

- Return the value of key OR returns a value if the key does not exist:
>>> <dict>.get(<key>, <value>)

- Show dict keys (object type: dict_keys):
>>> <dict>.keys()
>>> list(<dict>.keys())

- Show dict values (object type: dict_values):
>>> <dict>.values()
>>> list(<dict>.values())

- Show dict items (object type: dict_items):
>>> <dict>.items()
>>> list(<dict>.items())




------------------------------------

	TUPLES

- A tupla é imutável
- Os únicos dois métodos são count e index
- Mesmas formas de acesso e indexação de strings e lists funcionam em tuplas:

- Defining tuple;
>>> <tuple> = (<object> , ...)

- Return the index of a element:
>>> <tuple>.index(<object>)

- Count how many times a element is repeated:
>>> <tuple>.count(<object>)

- Tuple unpacking:
>>> (<elements>, ...) = <tuple>



- Defining a tuple with only one item:
>>> <tuple> = (<object>, )

------------------------------------

	FILES

- To read or write to a file, it needs to be opened. 
- When the work is done, it needs to be closed, so the resources tied with the file are freed.


- Current working directory (Jupyter):
>>> pwd

- Open a file:
>>> <file> = open('<file-path>')

- Specify the mode while opening a file.
>>> <file> = open('<file-path>', '<mode>')
>>> <file> = open('<file-path>', mode='<mode>')

Operations Mode:
	r - read (default), error if the file does not exist.
	w - write, creates the file if it does not exist. Overwrite if it does.
	a - append, creates the file if it does not exist.
	x - exclusive creation, creates the file, returns an error if the file exists.

Mode:
	t - text (default)
	b - binary


- When working with files in text mode, it is highly recommended to specify the encoding type.
- The default encoding is platform dependent. In Linux it is 'utf-8'. In windows, it is 'cp1252'.
- If relying on default the code will behave differently in different platforms.

>>> <file> = open('<file-path>', '<mode>', <encoding>)
>>> <file> = open('<file-path>', mode='<mode>', encoding=<encoding>)






- Read file content:
>>> <file>.read()
>>> <file>.read(<size>)

- Set cursor position:
>>> <file>.seek(<position>)
>>> <file>.seek(0)				# start of the file

- Return current cursor position:
>>> <file>.tell()

- Read file to the end of the line from cursor position:
>>> <file>.readline()

- Return a list with all lines from cursor position:
>>> <file>.readlines()


- Print each line:
>>> for line in <file>:
>>> 	print(line)





- Write to a file (this method returns the number of characters written):
>>> <file>.write('<content>')




SAFETY

- Close a file after it is used:
>>> <file>.close()

- If an exception occurs when performing a operation on the file, the code exits without closing it.
- Thus, a safer way to use de file is:


>>> with open('<file-path>', <encoding>) as <file>:
>>> 	<instructions>




STRINGIO

- Import:
>>> import io

- Create a file from a string:
>>> <file-obj> = io.StringIO(<string>)






------------------------------------

	SETS
	
- Sets only allow ordered non repeating values or elements.

- Defining a set:
>>> <set> = set(<iterable>)
>>> <set> = {<element>, ... ,<element>}

- Add elements to set:
>>> <set>.add(<element>)

- Discart element of a set:
>>> <set>.discard(<element>)


METHODS

- Clear set:
>>> <set>.clear()

- Create a copy of a set:
>> <copy-set> = <set>.copy()

- Return a set with the Difference between a set and another:
>>> <set>.difference(<another-set>)

- Update a set to be the Difference between anoter set:
>>> <set>.difference_update(<another-set>)

- Return a set with Intersection between a set and another:
>>> <set>.intersection(<anoter-set>)

- Update a set to be the Intersection with anoter set:
>>> <set>.intersection_update(<another-set>)

- Return a set as Union of a set and another:
>>> <set>.union(<anoter-set>)



	## Examples ##

- Get all values on a list, without repeating:
>>> l = [1,2,2,33,4,4,11,22,3,3,2]
>>> shit = list(set(l))
>>> print(shit)
[]	[1, 2, 33, 4, 3, 11, 22]

	## - ##



------------------------------------

	CODE FLOW CONTROL STRUCTURES

>>> if <boolean>:
>>> 	<instructions>
>>> elif <boolean>:
>>> 	<instructions>
>>> else:
>>> 	<instructions>


>>> <element/instruction> if <boolean> else <element/instruction>


>>> for <element> in <iterable>:
>>> 	<instructions>

- Iterables are: lists, dictionary keys, dictionary values, dictionary items, tuples, strings, iterators.

>>> for _ in <iterable>:
>>> 	<instructions>



- For/else/break (executes the else after the loop only if it didn't find a break):

>>> for <element> in <iterable>:
>>> 	<instructions>
>>> 	if <boolean>:
>>> 		<instructions>
>>> 		break
>>> else:
>>> <instructions>



- Tuple unpacking:
>>> (<elements>, ...) = <tuple>

- Create a range-sequence of Integers (default start = 0):
>>> range(<excluded-stop>)
>>> range(<included-start>, <excluded-stop>)
>>> range(<included-start>, <excluded-stop>, <step>)



	## Examples ##

>>> for (um, dois) in [ (1, 2), (3, 4), (5, 6) ]:
>>> 	print("%d x %d = %d" %(um,dois,um * dois))
[]	1 x 2 = 2
[]	3 x 4 = 12
[]	5 x 6 = 30

>>> for (key, value) in <dict>.items():
>>> 	print(key, ':', value)

	## - ##









>>> while <boolean>:
>>> 	<instructions>


>>> while <boolean>:
>>> 	<instructions>
>>> else:
>>> 	<instructions>



- Stop repetition:
	
>>> while True:
>>> 	<instructions>
>>> 	if <boolean>:
>>> 		break	# works on for and while



- Stop current iteration and continue repetition:
	
>>> while <boolean>:
>>> 	<instruction>
>>> 	if <boolean>:
>>> 		continue
>>> 	<instruction>



LIST COMPREHENSION

>>> [<element/instruction> for <element> in <iterable>]
>>> [<element/instruction> for <element> in <iterable> if <boolean>]
>>> [<element/instruction> if <boolean> else <element/instruction> for <element> in <iterable>]

>>> [<element/instruction> for <element> in <iterable> for <element> in <iterable> ...]








	## Examples ##

>>> range(0,10)
[]	range(0, 10)
>>> type(range(0,10))
[]	range
>>> list(range())
[]	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




>>> x = 0
>>> while x <= 10:
>>> 	x += 1
>>> 	if (x % 2) == 1:
>>> 		continue
>>> 	print (x, 'is even')
[]	2 is even
[]	4 is even
[]	6 is even
[]	8 is even
[]	10 is even




>>> l = [ (1, 2), (3, 4), (5, 6) ]
>>> (um, dois) = l[0]
>>> print (dois, um)
[]	2 1




- Print integers from 1 to 100, but for multiples of 3 print "Fizz" instead, for multiples of 5 print "Buzz" instead, and for multiples of both print "FizzBuzz" instead.

>>> for n in range(1,101): print('FizzBuzz') if (n%3==0 and n%5==0) else (print('Fizz') if n%3==0 else (print('Buzz') if n%5==0 else print(n)))


	## - ##

------------------------------------

	FUNCTIONS

- Defining simple function:
>>> def <function>():
>>> 	<instructions>

- Call function:
>>> <function>()

- Add Docstring (a type of description) to a function:
>>> def <function>():
>>> 	"""
>>> 	<Docstring>
>>> 	"""
>>> 	<instructions>


- Function with arguments:
>>> def <function>(<args>, ...):
>>> 	<instructions>


- Return:
>>> def <function>():
>>> 	<instructions>
>>> 	return <object>








ARGS & KWARGS

- Allows a function to handle undefined arguments and keyword-arguments.
- When the function is called, the extra arguments go to a 'args' Tuple.
- The extra keyword-arguments go to a 'kwargs' Dictionary.

>>> def <function>(*args, ...):
>>> 	<instructions>

>>> def <function>(**kwargs, ...):
>>> 	<instructions>












	## Examples ##

>>> def isprime(num):
>>>     """
>>>     Método pra checar se é primo
>>>     """
>>> 	for ind in range(2,num):
>>>         if num%ind == 0 :
>>>             print("Not prime")
>>>             break
>>>     else:
>>>         print("Prime")
>>> isprime(104729)
[]	Prime




>>> def func():
>>> 	a = 1
>>> 	print(locals())

>>> sameFunc = func()
[]	{'a': 1}
>>> type(sameFunc)		# func() returned nothing
[]	NoneType
>>> sameFunc = func
>>> def otherFunc(function):
>>> 	function()
>>> otherFunc(sameFunc)
[]	{'a': 1}



	## - ##


------------------------------------

	UNPACKING (aka STARRED EXPRESSIONS)

- Unpacking can be done with lists, tuples and dictionaries.

- Unpacking can be useful to use the items of a iterable as arguments for a function call requiring separated positional arguments.

- For lists and tuples it is used the '*' operator BEFORE the thing.

- For dictionaries it is used the '**' operator  BEFORE the thing.





	## Examples ##

>>> args = [5, 27, 3]
>>> list(range(*args))
[]	[5, 8, 11, 14, 17, 20, 23, 26]

>>> d = {'word':'butt' , 'l':'t'}
>>> print( ' {word} {l} {var}'.format( **d, var='shit' ))
[]	butt t shit

	## - ##

------------------------------------

	LAMBDA

- Função definida em uma única linha.
- Função "anônima".


- Defining a lambda function:
>>> lambda <args>, ... : <instruction>


- Atributing lambda to a label:
>>> <lambda> = lambda <args>, ... : <instruction>


------------------------------------

	NESTED STATEMENTS AND SCOPE

- Scopes order:

	1- local - inside functions

	2- enclosing functions locals - on local scope of any nested functions, from insideout

	3- global - in the top level of a file or declared as global in a function

	4- built-in (python) - pre-assigned




- Return a Dictionary of global or local variables:
>>> locals()
>>> globals()

>>> locals()['<variable-label>']
>>> globals()['<variable-label>']





	## Examples ##

- Locals (x):

>>> x = 'global'
>>> def func():
>>> 	x = 'local'
>>> 	print(x)

>>> print(x)
[]	global
>>> func()
[]	local




- Enclosing functions locals:

>>> def outterFunc():
>>> 	x = 'local'
>>> 	def innerFunc1():
>>> 		x = 'nested local'
>>> 		print (x)
>>> 	def innerFunc2():
>>> 		nonlocal x
>>> 		print (x)
>>> 	innerFunc1()
>>> 	innerFunc2()
>>> outterFunc()
[]	nested local
[]	local



>>> name = 'global'
>>> def greet():
>>> 	name = 'local'
>>> 	def hello():
>>> 		print(name)
>>> 	hello()
>>> greet()
[]	local



- Global:

>>> name = 'global'
>>> def greet():
>>> 	# now without the enclosing function local
>>> 	def hello():
>>> 		print(name)
>>> 	hello()
>>> greet()
[]	global





>>> x = 'global'
>>> def func():
>>> 	global x
>>> 	x = 'not local, global'
>>> 	print(x)

>>> func()
	not local, global
>>> print(x)
	not local, global




	## - ##


------------------------------------

	OBJECT ORIENTED: CLASSES, PROPERTIES AND METHODS, INHERITANCE, SPECIAL METHODS


- Classes have a Initialization Function, aka Constructors (__init__). Used to assign values to attributes and do operations necessary when the object is being created.

- The 'self' parameter is reference to the current instance of the class. It is used to access attributes of the class. It doesn't need to be 'self', it can be whatever, but it has to be the first parameter of any function in the class.


- Create a Class:

>>> class <Class>:
>>> 	
>>> 	<attributes>
>>> 	
>>> 	def __init__(self, <parameters>, ...):
>>> 		self.<property> = <parameter>
>>> 	
>>> 	def <methods>(self, <parameters>, ...):
>>> 		<instructions>




- Create an object (instance) from a Class:

>>> <object> = <Class>()



- Call a method:

>>> <object>.<method> (<args>, ...)



INHERITANCE

- A Class can inherit attributes and methods from other class.

- A child Class can overwrite the methods inherited from the parent Class. After that, it is still possible to access the the parent's methods.



- Create a Class that inherit the properties and methods from other Class:

>>> class <Class> (<parent-Class>):
>>> 	
>>> 	<attributes>
>>> 	<__init__>
>>> 	<methods>
>>> 	
>>> 	# Overwriting a parent method:
>>> 	
>>> 	def <parente-method>(self, <parameters>, ...):
>>> 		<new-instructions>
>>> 	
>>> 	# Using a overwriten parent method:
>>> 	
>>> 	<parent-Class>.<parente-method>()



SPECIAL METHODS

- More info on special methods: https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html
- More info on special methods: https://diveintopython3.net/special-method-names.html

- Special methods:

>>> class <Class>:
>>> 	
>>> 	# Constructor. Behavior of '<object> = <class>()'
>>> 	
>>> 	def __init__(self, <parameters>, ...):
>>> 		self.<property> = <parameter>
>>> 	
>>> 	
>>> 	# Behavior when using '<object> + <other-object>'
>>> 	
>>> 	def __add__(self, <other-object>):
>>> 		<instructions>
>>> 	
>>> 	
>>> 	# Return when used the 'len(<object>)' function
>>> 	
>>> 	def __len__(self):
>>> 		return <attribute/method>
>>> 	
>>> 	
>>> 	# Behavior of '<object>[<key>]
>>> 	
>>> 	def __getitem__(self, key):
>>> 		return <attribute/method>
>>> 	
>>> 	
>>> 	# Return when 'str(<object>)' or 'print(<object>)'
>>> 	
>>> 	def __str__(self):
>>> 		return <str>
>>> 	
>>> 	
>>> 	# Behavior when object deleted by del(<object>)
>>> 	
>>> 	def __del__(self):
>>> 		<instructions>








- Delete attributes on objects, or delete whole objects:

>>> del <object>.<attribute>

>>> del <object>





- Save object to file:
- /python-modules/python-pickleshare-catalog
- Also:
https://stackoverflow.com/questions/4529815/saving-an-object-data-persistence


------------------------------------

	ERRORS: TRY & EXCEPT

- Try code with possible errors.
- In case of a specific Exception, treat as specified on the except block. If the Exception is not specified, any error will be treated.
- If none of the Exceptions occur, do 'else'.
- To Capture the error message use 'except Exception as <object>'
- The 'finally' block runs independent of  what happens ( useful in case of: a return on the except block, if a Exception is thrown in the except block, if a Exception is thrown on the try block, but is not treated on any except block in which case finally is executed before the Exception is propagated).

>>> try:
>>> 	<instructions>
>>> 	
>>> except <Exception>:
>>> 	<instructions>
>>> 	
>>> except ...
>>> 	...
>>> 	
>>> except Exception as <object>:
>>> 	<instructions>
>>> 	
>>> else:
>>> 	<instructions>
>>> 	
>>> finally:
>>> 	<instructions>




------------------------------------

	PACKAGES AND MODULES

- Some built-in libraries:
math
ramdom
os
time
pickle
line_profiler
numpy


- Available:
[pacman]	python-gmpy2
			Provides C-coded Python modules for fast multiple-precision arithmetic.
			(https://github.com/aleaxit/gmpy)
			(https://gmpy2.readthedocs.io/en/latest/mpfr.html)
			
[conda]		gmpy2
			GMP/MPIR, MPFR (Multiple Precision Floating-point Rounding), and MPC interface to Python 2.6+ and 3.x




(more info: https://docs.python.org/2/tutorial/modules.html#packages)
(See 'if __name__ == "__main__"' firefox-bookmark for more info)

- A directory with a file '__init__.py' can be called a Package, and the files within are seen by Python as Modules.
- If a package has a '__init__.py', once it is imported, this file is executed. Also, it will have "priority", meaning it wont search the module on other paths with same name.
- If it doesn't has '__init__.py', is is trea as a namespace package (?), and will search the module on the current folder and on python's path.


<project>/
|
|	<main>.py
|	<module-a>.py
|	...
|	
|	<package>/
|	|
|	|	__init__.py
|	|	<module-b>.py
|	|	...
|	|	
|	|	<sub-package>/
|	|	|
|	|	|	__init__.py
|	|	|	<module-c>.py
|	|	|	...
|	|	|
|	|
|





- Import:

>>> import .<module-a>
>>> import <package>.<module-b>
>>> import <package>.<sub-package>.<module-c>

>>> import <module>
>>> import <module> as <name>

>>> from <module> import *
>>> from <module> import <function>
>>> from <package>.<module> import <function>
>>> from <package>.<sub-package>.<module> import <function>







	(basically, never use pip)
	(conda on Virtual Enviroment)
	(pacman on the system)

	WARNING: NEVER run 'pip install <module>' on the TERMINAL. You should never make any changes to '/usr', except through pacman. If you need to install with pip do it in a Virtual Enviroment (like conda).

	(if a package isn't available by conda, try conda-forge before even thinking on pip)
	(https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages)


- Install packages on current env:
(<env>)$ conda install <package>
(<env>)$ conda install <package>=<version>

- Install packages on other env:
$ conda install <package> -n <env>

- Search package:
$ conda search <package>

- Search package info:
$ conda search <package> --info

- List installed package:
$ conda list
$ conda list <package>


- Check available updates:
$ conda update

- Update a package:
$ conda update <package>
$ conda update python
$ conda update conda
$ conda update anaconda

- Remove a packages:
(<env>)$ conda install <package>
$ conda install <package> -n <env>







- Display where Python looks for modules:
>>> import sys
>>> type(sys.path)
[]	list
>>> print('\n'.join(sys.path))


- Add directory temporarily to the 'sys.path' list, to be seen as a package:
>>> import sys
>>> sys.path.append('<absolute-path>')


- Add directory permanently to 'sys.path':
Using PYTHONPATH: (https://bic-berkeley.github.io/psych-214-fall-2016/using_pythonpath.html)
Making a Python Package: (https://packaging.python.org/tutorials/packaging-projects/)


- Find where a molude is:

>>> import <module>
>>> <module>.__file__

>>> import imp
>>> imp.find_module('<module>')

(The '__file__' attribute is not present for C modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file.)












	## Examples ##



'__init__.py'
>>>

'<main>.py'
>>> from <package>.<module> import <function>






'__init__.py'
>>> from .<module> import *

'<main>.py'
>>> from <package> import <function>





>>> import os
>>> clear = lambda: os.system('clear')





- Importing a function:
>>> import os
>>> cwd = os.getcwd()								# currently working directory
>>> os.chdir("<directory-of-the-function-file>")	# REMEMBER TO USE UNDERSCORE (_) INSTEAD OF HIFEN (-) ON FILES YOU GONNA IMPORT FROM
>>> from <file> import <function>

>>> os.chdir(cwd)


	## - ##

------------------------------------

	MAP, REDUCE, FILTER, ZIP, ENUMERATE, ALL & ANY

- MAP
- Aply a function to all of a iterable's elements.
- Returns a memory instruction (map type object).
- Do not use the paranthesis on the function.
- You can define a lambda right on the map() argument.

>>> map(<function>, <iterable>)
>>> map(<lambda>, <iterable>)

>>> list(map(<function>, <iterable>))





- REDUCE
- Aply a function to all of a iterable's elements, two by two.
- Initially with the first two, and then, with it's result and the next from the iterable.
- Goes until it is reduced to a single element which is returned.

>>> from functools import reduce	# Python 3
>>> reduce(<function>, <iterable>)





- FILTER
- Uses a filter function with boolean return to exclude items in an iterable object.
- Returns a memory instruction (filter type object).

>>> filter(<function>, <iterable>)





- ZIP
- Returns an iterable of tuples from two or more iterables.
- Each item with the same index from each iterable is paired together in a tuple.
- If the iterables have different lengths, the zip has the size of the smaller one.
- Returns a memory instruction (zip type object).

>>> zip(<iterable-1>, <iterable-2>, ...)





- ENUMERATE
- Takes a collection (iterable) and adds a counter as key in a tuple with each item.
- By default stars the counter from 0.
- Returns a memory instruction (enumerate type object).

>>> enumerate(<iterable>)
>>> enumerate(<iterable>, <start>)





- ALL & ANY
- Returns True if (all or any) items in an iterable object are true.
- If the iterable is empty, all() returns True and any() False.

>>> all(<iterable>)

>>> any(<iterable>)





	## Examples ##

>>> celsius = [0, 9, 10, 15, 20, 22, 30, 40, 50, 90, 100, 120]
>>> fahrenheit = list(map(lambda temp: temp * (9/5) + 32, celsius))
[]	[32.0, 48.2, 50.0, 59.0, 68.0, 71.6, 86.0, 104.0, 122.0, 194.0, 212.0, 248.0]



>>> from functools import reduce
>>> values = [47, 11, 42, 13]
>>> biggest = reduce( (lambda a,b: a if a>b else b) , values )
[]	47



>>> ages = [5, 12, 17, 18, 24, 32]
>>> underage = list(filter( (lambda ag: False if x>18 else True) , ages))
[]	[5, 12, 17]



>>> uCase = ['A', 'B', 'C']
>>> lCase = ['a', 'b', 'c']
>>> nums = (1, 2, 3, 4, 5)
>>> list(zip(uCase, lCase, nums))
[]	[('A', 'a', 1), ('B', 'b', 2), ('C', 'c', 3)]



- Remove all items in Python list containing a number:
>>> foo = ['This', 'That', 'Those4423', '42', '13b', 'Yes', '2']
>>> [word for word in foo if not any(letter.isdigit() for letter in word)]


	## - ##



------------------------------------

	DECORATORS & CLOSURE

- Make a Function that add other functionalities (Decorate) to a (existing or new) function:

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( <parameters> ):
>>> 		<instructions>
>>> 		return <in-func>( <parameters> )
>>> 	
>>> 	return <out-func>

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( <parameters> ):
>>> 		<instructions>
>>> 		<in-func>( <parameters> )
>>> 		<instructions>
>>> 	
>>> 	return <out-func>





- Decorate existing functions:

>>> <new-func> = <decorator> (<func>)


- Decorate new functions:

>>> @<decorator>
>>> def <func> ():
>>> 	<instructions>



- Multiple decorators can be chained:

>>> <new-func> = <decorator1> ( <decorator2> ( ... (<func>)))

>>> @<decorator1>
>>> @<decorator2>
>>> ...
>>> def <func> ():
>>> 	<instructions>





- Make general decorators that work with any number of parameters.
- 'args' will be the tuple of positional arguments
- 'kwargs' will be the dictionary of keyword arguments

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( *args, **kwargs ):
>>> 		<instructions>
>>> 		return <in-func>( *args, **kwargs )
>>> 	
>>> 	return <out-func>

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( *args, **kwargs ):
>>> 		<instructions>
>>> 		<in-func>( *args, **kwargs )
>>> 		<instructions>
>>> 	
>>> 	return <out-func>




CLOSURE

- Get some data attached (Closure) to a function.
- By using this, once defined, the function will hold a "hidden" data.
- Can be used to create objects storing data withou the need to make a Class.

>>> def <closure>( <variables> ):
>>> 
>>> 	def <out-func>():
>>> 		<instructions>( <variables> )
>>> 	
>>> 	return <out-func>

>>> <func> = <closure>( <data> )





- Accessing Enclosed Values.
- Enclosed function objects have '__closure__' attribute with tuple of cell objects.
- The cell object has the attribute 'cell_contents' which stores the closed value.

>>> <enclosed-func>.__closure__

>>> <enclosed-func>.__closure__[<index>].cell_contents







	## Examples ##

>>> def make_multiplier(n):
>>> 	
>>> 	def multiplier(x):
>>> 		return x * n
>>> 	
>>> 	return multiplier

>>> times3 = make_multiplier(3)
>>> times3(9)
[]	27

>>> times5 = make_multiplier(5)
>>> times5(9)
[]	45

>>> def addExplaning(func):
>>> 	
>>> 	def outFunc(x):
>>> 		print("I'm a function that multiplies %d by the given number %d:" %( func.__closure__[0].cell_contents, x))
>>> 		return func(x)
>>> 	
>>> 	return outFunc
>>> 
>>> times5 = addExplaning(times5)
>>> print(times5(9))
[]	I'm a function that multiplies 5 by the given number 9:
[]	45

	## - ##

------------------------------------

	ITERATORS & GENERATORS

- A Python Iterator Object must implement the methods '__iter__()' and '__next__()' (iterator protocol).
- The 'next()' and 'iter()' functions call the '__next__()' and '__iter__()' methods.
- The 'next()' function manually iterate through all the items.
- When reachs the end raises the 'StopIteration' Exception.
- The 'iter()' function returns an iterator from a object.

>>> <iterator> = iter(<iterable>)

>>> next (<iterator>)

>>> class <custom-iterator>:
>>> 	
>>> 	def __init___(self, max=0):
>>> 		self.n = 0
>>> 		self.max = max
>>> 	
>>> 	def __iter__(self):
>>> 		return self
>>> 	
>>> 	def __next__(self):
>>> 		if self.n > self.max:
>>> 			raise StopIteration
>>> 		
>>> 		<instruction>
>>> 		self.n += 1
>>> 		return <value>

>>> <obj> = <custom-iterator>(<max>)
>>> <iterator> = iter(<obj>)



GENERATOR

- Function that generates and returns a iterator.
- When called, returns a iterator object, but does not start execution immediately.
- Mehods '__iter__()' and '__next__()' are implemented automatically.
- Local variables are not destroyed when the function yields.
- The generator object can be iterated only once.

- Can be used to represent an infinite stream of data.

>>> def <gerenator>():
>>> 	<instructions>
>>> 	yield <value>

>>> <iterator> = <gerenator>()

>>> next (<iterator>)





- Gerenator Expression.
- Much more memory efficient than an equivalent list comprehension.

>>> (<element/instruction> for <element> in <iterable>)
>>> (<element/instruction> for <element> in <iterable> if <boolean>)
>>> (<element/instruction> if <boolean> else <element/instruction> for <element> in <iterable>)





	## Examples ##

>>> def PowTwo(max=0):
>>> 	n = 0
>>> 	
>>> 	while n < max:
>>> 		yield 2 ** n
>>> 		n += 1

>>> numbers = PowTwo(3)		# object
>>> i = iter(numbers)		# iterator

>>> for i in PowTwo(3):
>>> 	print(i, end=' ')
[]	1 2 4 8 


# Sum of the squares of the numbers in the Fibonacci Sequence
>>> def fibonacci_numbers(nums):
>>> 	x, y = 0, 1
>>> 	for _ in range(nums):
>>> 		x, y = y, x+y
>>> 		yield x
>>> 
>>> def square(nums):
>>> 	for num in nums:
>>> 		yield num**2
>>> 
>>> print(sum(square(fibonacci_numbers(100))))
[]	203023208030065646654504166904697594722575


	## - ##

------------------------------------

	DEBUGGING

- Evaluate a boolean and throw a 'AssertionError' (and message) if False:
>>> assert <boolean>
>>> assert <boolean>, <str-message>


PYTHON DEBUGGER

- Can create a interactive debugging point (set_trace).
- On it, while running, the code pauses.
- Then, it is possible to modify variables, check their values, etc..
- Once we are done, type 'c' to continue execution.

- Import:
>>> import pdb

- Create a set_trace:
>>> pdb.set_trace()

Commands:
	h	help		- Print available commands.
	c	continue	- Continue execution.

More Commands:
(https://docs.python.org/dev/library/pdb.html#debugger-commands)


------------------------------------

	COLLECTIONS MODULE




COUNTER

- Import:
>>> from collections import Counter

- Count how many times each element appears in a iterable (returns a type Counter object):
>>> Counter(<iterable>)

- See a number of elements ordered by most common appearences (default=all):
>>> Counter(<iterable>).most_common()
>>> Counter(<iterable>).most_common(<number>)

- Common methods for Counter:
>>> Counter.values()
>>> Counter.items()			# From a Counter to a List of pairs in Tuples.
>>> Counter(dict(<list>))	# From a List of pairs in Tuples to a Counter.
>>> Counter.clear()			# Redefine counts (?).





DEFAULTDICT

- Does not return a error when trying to access a non existing key.
- The defaultdict has a default item, which might be a type object (int, list, object, functions ...) or a function.
- When it tries to access a item with a key that doesn't exist it creates the item using the default item.

- Import:
>>> from collections import defaultdict

- Create a DefaultDict with a default item:
>>> <d-dict> = defaultdict(<type-object/function>)






	## Examples ##

>>> from collections import defaultdict

>>> d = defaultdict(lambda : 42)
>>> d['existent'] = 0
>>> d['existent']
[]	0
>>> d['non-existent']
[]	42

>>> str = 'mississippi'
>>> d = defaultdict(int)
>>> for letter in str:
>>> 	d[letter] += 1

>>> d.items()
[]	dict_items([('m', 1), ('i', 4), ('s', 4), ('p', 2)])


>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
>>> d = defaultdict(list)
>>> for color, value in s:
>>> 	d[color].append(value)

>>> d.items()
[]	dict_items([('yellow', [1, 3]), ('blue', [2, 4]), ('red', [1])])

	## - ##





NAMEDTUPLE

- Named tuples are basically easy-to-create, lightweight object types.

- Import:
>>> from collections import namedtuple

- Create a Named Tuple 'Class' with a name and parameters (separated by spaces) that can holf values:
>>> <n-tuple> = namedtuple('<name>', '<parameter> ... <parameter>')

- Instanciate a Named Tuple:
>>> <instance> = <n-tuple>(<value>, ... ,<value>)
>>> <instance> = <n-tuple>(<parameter> = <value>, ... ,<parameter> = <value>)

- Access the value from a Named Tuple's parameter:
>>> <instance>.<parameter>

	## Examples ##

>>> from collections import namedtuple
>>> Point = namedtuple('Point', 'x y')
>>> pt1 = Point(1.0, 5.0)
>>> pt2 = Point(2.5, 1.5)

>>> from math import sqrt
>>> line_length = sqrt((pt1.x - pt2.x)**2 + (pt1.y - pt2.y)**2)
[]	3.8078865529319543

	## - ##




------------------------------------

	DATETIME


- Import:
>>> import datetime

- Create a Time Stamp with time info:
>>> <time-stamp> = datetime.time(<hour>,<minute>,<second>)

- Access parameters:
>>> <time-stamp>.hour
>>> <time-stamp>.minute
>>> <time-stamp>.second
>>> <time-stamp>.microsecond
>>> <time-stamp>.tzinfo			# timezone

- Parameters info:
>>> datetime.time.min
>>> datetime.time.max
>>> datetime.time.resolution




- Create a Time Stamp with date info:
>>> <time-stamp> = datetime.date(<year>,<month>,<day>)
>>> <time-stamp> = datetime.date.today()



- Create a Time Stamp with both time and date info:
>>> <time-stamp> = datetime.datetime(<year>,<month>,<day>)
>>> <time-stamp> = datetime.datetime(<year>,<month>,<day>,<hour>,<minute>,<second>)



- More complete info about Date Stamp:
>>> <time-stamp>.ctime()


	## Example ##

>>> today = datetime.datetime(2020,11,25,11,9,25)
>>> today.ctime()
[]	'Wed Nov 25 11:09:25 2020'

	## - ##


	
	
- Convert DateTime Objects to String (Formating):
>>> <time-stamp>.strftime(<format>)

- Convert String to DateTime Objects (Parsing):
>>> <time-stamp> = datetime.strptime(<string>, <format>)


Formats:
	%Y	-	Year
	%y	-	Year without century as a decimal number [00,99].
	%m	-	Month as a decimal number [01,12].
	%d	-	Day as a decimal number [01,31].

More Formats:
(https://docs.python.org/dev/library/time.html#time.strftime)



------------------------------------

	EXECUTION TIME

- Import:
>>> import timeit

- Measure and sum execution time of a single-line code, for a number of executions:
>>> timeit.timeit('<instruction>', number=<executions-times>)

	## Examples ##

>>> "-".join(str(n) for n in range (10))
[]	'0-1-2-3-4-5-6-7-8-9'
>>> "-".join(map(str, range (10)))
[]	'0-1-2-3-4-5-6-7-8-9'
>>> timeit.timeit('"-".join(str(n) for n in range (100))', number=100000)
[]	3.819706880999547
>>> >>> timeit.timeit('"-".join(map(str, range (100)))', number=100000)
[]	2.6763063040007182

	## - ##


- On Jupyter notebook, is possible to use Timeit to get statistics about the execution:
>>> %timeit <instruction>


	## Examples ##

>>> %timeit "-".join(str(n) for n in range (100))
[]	35.1 µs ± 2.09 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
>>> %timeit "-".join(map(str, range (100)))
[]	24.4 µs ± 918 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

	## - ##


LINE PROFILER

- Analyse a code and show which part or line is wasting more time.

- Package: line_profiler

- Info: (https://zapier.com/engineering/profiling-python-boss/)
- Read the article before using it.

- Set up:

	try:
		from line_profiler import LineProfiler

		def do_profile(follow=[]):
			def inner(func):
				def profiled_func(*args, **kwargs):
					try:
						profiler = LineProfiler()
						profiler.add_function(func)
						for f in follow:
							profiler.add_function(f)
						profiler.enable_by_count()
						return func(*args, **kwargs)
					finally:
						profiler.print_stats()
				return profiled_func
			return inner

	except ImportError:
		def do_profile(follow=[]):
			"Helpful if you accidentally leave in production!"
			def inner(func):
				def nothing(*args, **kwargs):
					return func(*args, **kwargs)
				return nothing
			return inner



- Just decorate your test function and pass the problem function in the follow argument!
- Example of usage:


	def get_number():
		for x in xrange(5000000):
			yield x

	@do_profile(follow=[get_number])
	def expensive_function():
		for x in get_number():
			i = x ^ x ^ x
		return 'some result!'

	result = expensive_function()



------------------------------------

	REGULAR EXPRESSIONS

- Info: (https://docs.python.org/dev/library/re.html)

- Find text patterns.
- Using Unicode charaters.
- Returns a Match Object.
- Returns nothing if pattern not found.
- Span is a tuple with initial and final position for matches found.

- Import:
>>> import re

- Find a pattern on a string:
>>> re.search(<pattern>, <string>)

- Match Object methods:
>>> <match>.start()			# Position of first match
>>> <match>.end()			# End of last match


- Pattern Repetition Syntax:
	\		Escapes special characters.
	*		Match 0 or more repetitions of the preceding RE.
	+		Match 1 or more repetitions of the preceding RE.
	?		Match 0 or 1 repetitions of the preceding RE.
	{m}		Exactly m copies of the previous RE should be matched.
	{m,n}	Match from m to n repetitions of the preceding RE.
			Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound (comma may not be omitted).
	A|B		Match either A or B
	[]		Indicate a set of possible characters.
			[-]		Range of possible characters. Examples:
					[a-z]			From a to z.
					[0-9A-Fa-f]		Any hexadecimal digit.
					[0-5][0-9] 		All two-digits numbers from 00 to 59.
			[^]		Complementing the set.
					'^' has no special meaning if it’s not the first character in the set.
					Example:
					[^5]		Any character except '5'.
					[^^]		Any character except '^



RE METHODS

- Split strings on patters:
>>> re.split(<pattern>, <string>)

- Find all matches and Return it:
>>> re.findall(<pattern>, <string>)






	## Examples ##

>>> import re
>>> patterns = ['term1', 'term2']
>>> text = 'String with term1. Another with term2.'
>>> re.search(patterns[0], text)
[]	<re.Match object; span=(12, 17), match='term1'>

>>> for patt in patterns:
>>> 	if re.search(patt, text[:18]):
>>> 		print('Found "%s" in "%s".' % (patt, text[:18]))
>>> 	else:
>>> 		print('Didn´t found "%s" in "%s".' % (patt, text[:18]))
[]	Found "term1" in "String with term1.".
[]	Didn´t found "term2" in "String with term1.".

	## - ##


------------------------------------

	GUI

- List of common frameworks for GUI:
(https://wiki.python.org/moin/GuiProgramming)

- Recommended:
	PyQt		- Because
	PyGame		- For graphic games
	ipywidgets	- For Jupyter



- Tip:
	"Se você quer construir aplicativos web, provavelmente vai querer evitar o Python como GUI e usá-lo para o trabalho de back-end usando Flask ou Django. Com os aplicativos da Web, você desejará explorar HTML, CSS e Javascript para fornecer a GUI para seu usuário."



IPYWIDGETS

- GUIs for Jupyter
- Package: ipywidgets
- For jupyte lab:
(<env>) $ conda install nodejs npm
(<env>) $ jupyter labextension install @jupyter-widgets/jupyterlab-manager



- Import:
>>> from ipywidgets import interact, interactive, fixed
>>> import ipywidgets as wid



- Make a Widget for inputs (int, boolean, string, tuple, dictionaries ...) of a function with return, giving a initial value:
>>> interact(<function>, <input>=<value>, ... , <input>=<value>)

- Make a Widget, fixing some of the inputs:
>>> interact(<function>, <input>=<value>, <input>=fixed(<value>))





- Slider Widget:

>>> interact(<function>, <input>=wid.IntSlider(min=<value>, max=<value>, step=<value>, value=<value>))
>>> interact(<function>, <input>=wid.FloatSlider(min=<value>, max=<value>, step=<value>, value=<value>))

>>> interact(<function>, <input>=(<min>, <max>))
>>> interact(<function>, <input>=(<min>, <max>, <step>))





- Get an instance of Widget:
>>> <widget> = interactive(<function>, <input>=<value>, ...)

- Display instance of Widget:
>>> from IPython.display import display
>>> display(<widget>)

- Close Widget:
>>> <widget>.close()

- Get current arguments from Widget:
>>> <widget>.kwargs

- Get current return of Widget:
>>> <widget>.result






- Create a Button that executes a function every time it is clicked:
>>> <button> = wid.Button(description=<string>)
>>> <button>.on_click(<function>)
>>> display(<button>)
 

 
 - Create a Widget that executes a function when text is submitted:
 >>> <text-widget> = wid.Text()
 >>> <text-widget>.on_submit(<function>)
 >>> display(<text-widget>)
 
 
 
 
 
 - A fucking bunch of Widgets:
 
 >>> wid.Text(value=<string>, description=<string>)
 >>> wid.Textarea(value=<string>, description=<string>)
 
 >>> wid.IntSlider(min=<value>, max=<value>, step=<value>, value=<value>)
 
 >>> wid.FloatSlider(min=<value>, max=<value>, step=<value>, value=<value>)
 >>> wid.FloatSlider( ... , orientation = 'vertical')
 
 >>> wid.FloatProgress(value=<value>, min=<value>, max=<value>, description=<string>)
 
 >>> wid.BoundedFloatText(value=<value>, min=<value>, max=<value>)
 
 >>> wid.CheckBox(value=<boolean>, description=<string>)
 >>> wid.ToggleButton(value=<boolean>, description=<string>)
 
 >>> wid.Dropdown(options=<list/dictionary>, value=<value>, description=<string>)
 >>> wid.RadioButtons(options=<list/dictionary>, value=<value>, description=<string>)
 
 
 
 
 
 
------------------------------------




------------------------------------







------------------------------------

	TITTLE

- 





	## Examples ##



	## - ##


------------------------------------



------------------------------------



------------------------------------



------------------------------------







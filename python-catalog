

		PYTHON


------------------------------------

	JUPYTER/CONDA


- List enviroments:
$ conda env list

- Activate/deactivate enviroment (conda>=4.6):
$ conda activate <enviroment>
$ conda deactivate <enviroment>

$ conda activate udemy

- Open jupyter:
$ jupyter notebook
$ jupyter notebook <file.ipynb>
$ jupyper lab
$ jupyper lab <file.ipynb>


- List running Jupyter servers:
$ jupyter notebook list

- Terminate Jupyter server:
$ jupyter notebook stop
$ jupyter notebook stop <port>


- Jupyter shortcuts:

[shift] + [Enter]: run cell & go next
[ctrl] + [Enter]: run cell & DON'T go next
[alt] + [Enter]: run cell & add one cell

[d] + [d]: Delete selected cell


------------------------------------

	MARKDOWN FORMATING (jupyter)

# Bigger
**negrito**
*itálico*


------------------------------------

	PYTHON HELP


<py-object>. + [tab]: Show possible methods for the object (on jupyter)

<py-object>. + [shift] + [tab]: Show object documentation (on jupyter)
<function>() + [shift] + [tab]: Show function documentation (on jupyter)


- Display the type of a object:
>>> type(<object>)

- Python documentation about object:
>>> help(<py-object-type>)


------------------------------------


	OPERATORS PREDECEDENCE:

	**				Exponential
	~  +  -			Complement (all bits reversed), unary plus and minus
	*  /  %  //		Multiply, devide, modulo, floor division
	+  -
	>> <<			Right and left bitwise shift
	&				Bitwise AND
	^  |			Bitwise XOR and OR
	<=  <  >  >=
	=  %=  /=  //=	Assignment operators
	-=  +=  *= **=	Assignment operators
	is is not		Identity operators
	in not in		Membreship operators
	not or and		Logical operators


## Examples ##

		9 | 4
		  |---
Mod ->	1 | 2	<- Floor division

- Division:
>>> 9/4
	2.25

- Floor division:
>>> 9//4
	2

- Mod:
>>> 9 % 4
	1





------------------------------------

	STRINGS

## Examples ##

>>> ' Eu sou A. '
>>> " I'm A. "
>>> ' Citação: "A". '

>>>  print('\t Hello \n\t World')
		Hello
		World





- Tamanho (size):
>>> len(<string>)


- Access element:
>>> <string>[<index>]

## Examples ##
>>> someString = 'FUCKING HELP ME'
>>> someString[0]
	F




- Access multiple elements:
>>> <string>[<included-start>:<excluded-stop>]

## Examples ##
>>> someString[:]
	FUCKING HELP ME
>>> print( someString[:4] , someString[13:] )
	FUCK ME





- Access elements with some frequency (increment):
>>> <string>[::<step>]

## Examples ##
>>> someString[::2]
	FCIGHL E
>>> someString[::-1]
	EM PLEH GNIKCUF




- Concatenate:
>>> <string> + <string>
>>> <string> * <int-num>

## Examples ##
>>> someString + ", BITCH"
	FUCKING HELP ME, BITCH
>>> (someString[:4] + someString[7]) * 10
	FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK FUCK 




- Some methods:


>>> someString.lower()
	fucking help me
>>> someString.islower()
	True
	
>>> someString.upper()
	FUCKING HELP ME
>>> someString.isupper()
	True


>>> someString.split()
	['FUCKING', 'HELP', 'ME']


>>> someString.replace('ING HELP', '')
	FUCK ME


>>> '  |separator|  '.join(['FUCKING', 'HELP', 'ME'])
	FUCKING  |separator|  HELP  |separator|  ME



------------------------------------

	STRING FORMATING

- Formating Operators:

>>> ' %<form-op> ' % <obj>
>>> ' %<form-op>  %<form-op>  ...  %<form-op> ' % (<obj>, <obj>, ..., <obj>)


- Formating Operators:

%s - String (or any object with a string representation, like numbers)
%<total>s - total space for the string (negative to align left)

%d - Integers

%f - Floating point numbers

%<total>.<decimal>f - Floating point numbers with a fixed amount of decimal cases precision and a total space for the hole numer (negative to align left)

%x - Integers in hex representation (lowercase)
%X - Integers in hex representation (uppercase)





- New formating (permanently) method:

>>> ' {} '.format(<string>)
>>> ' {}  {}  ...  {} '.format(<string>, <string>, ..., <string>)

>>> ' {}  {}  ...  {} '.format( <dict> )

- Format unpacking tuple:

>>> ' {}  {}  ...  {} '.format( * <tuple> )




>>> ' {<spec-op>:<form-op>} '


- Specifiers Operators:

{} - the strings will be aplied in the order they are passed on 'format()'

{<number>} - positional argument for the strings given to 'format()'

{<key>} - keyword argument, keywords must be defined on the 'format()' arguments


- Formating Operators:

{:b} - binary

{:e} - exponent representation (scientific)

{:<total>} - total size of string format

{:.<decimal>} - number of decimal cases
{:<total>.<decimal>}

{:f} - any number represented as float
{:.<decimal>f}
{:<total>.<decimal>f}

{:<} - left align
{:^} - center align
{:>} - right align




## Examples ##

>>> numerooo = 69.69
>>> otro_num = 27
>>> a = 'Formating operators:\n'
>>> n = 'Número como string: %s\n'
>>> i = 'Inteiro:  %d\n'
>>> f = 'Float(1 decimal):[%12.3f] \n                 [123456789-12]\n'
>>> h = 'Hexadecimal: %X '
>>> print( a, n % numerooo, i % numerooo, f % numerooo, h % otro_num)
	Formating operators:

	Número como string: 69.69 
	Inteiro:  69 
	Float(1 decimal):[      69.690] 
	                 [123456789-12] 
	Hexadecimal: 1B




>>> data = ("John", "Doe", 53.44)
>>> format_string = "Hello %s %s. Your current balance is $%s."
>>> print(format_string % data)




>>> aurelio = 'One: {a}\nTwo: {b}\nThree: {c}'
>>> print(aurelio)
	One: {a}
	Two: {b}
	Three: {c}
>>> aurelio.format(a=1, b='two', c=12.3)
>>> print(aurelio)
	One: {a}
	Two: {b}
	Three: {c}



>>> ' {2} {0} {3} {1} '.format( 'one', 'three', 'zero', 'two' )
	' zero one two three '

	
>>> b='bee'
>>> c='see'
>>> ' {a} {b} {c} '.format( b=b, c=c, a='eei' )
	' eei bee see '


>>> "Binary representation of {0} is {0:b}".format(12)






------------------------------------

	LISTS

- Em python, listas permitem múltiplos tipos de dados e o tamanho não é fixo

- Mesmas formas de acesso e indexação de strings funcionam em listas:

## Examples ##
>>> asdf = [1,2,'minha juda']

>>> print(asdf[::-1])
	['minha juda', 2, 1]

>>> print(asdf[-1][::-1])
	aduj ahnim





- Append Method:
>>> <list>.append(<list>)
>>> <list> + <list>

- Remove a element from a list and print it (default-index: -1):
>>> <list>.pop()
>>> <list>.pop(<index>)


- Reverse list elements:
>>> <list>.reverse()

- Sort list elements:
>>> <list>.sort()

- Get the list elements sorted (without altering the string):
>>> sorted(<list>)


- List comprehension:
>>> [<element/instruction> for <element> in <iterable>]
>>> [<element/instruction> for <element> in <iterable> if <boolean>]
>>> [<element/instruction> if <boolean> else <element/instruction> for <element> in <iterable>]

>>> [<element/instruction> for <element> in <iterable> for <element> in <iterable> ...]

>>> {<key>: <value> for (<key>, <value>) in <iterable>}





## Examples ##


>>> l_1 = [1,2,3]
>>> l_2 = [4,5,6]
>>> l_3 = [7,8,9]
>>> matrix = [l_1, l_2, l_3]

>>> first_col = [row[0] for row in matrix]
	[1, 4, 7]
>>> first_col = list(list(zip(*matrix))[0])
	[1, 4, 7]
>>> diag = [matrix[ind][ind] for ind in [0,1,2] ]
	[1, 5, 9]
>>> diag2 = [matrix[ind][2-ind] for ind in [0,1,2] 
	[3, 5, 7]
>>> fulllist = [ matrix[i][j]  for i in [0,1,2] for j in [0,1,2]]
	[1, 2, 3, 4, 5, 6, 7, 8, 9]





>>> celsius = [0, 10, 15, 20, 30, 50, 100]
>>> fahrenheit = [ temp*(9/5)+32  for temp in  celsius ]
>>> [int(f) for f in fahrenheit]
	[32, 50, 59, 68, 86, 122, 212]






>>> # Multiply matrix

>>> X = [[12,7,3],
>>> 	[4 ,5,6],
>>> 	[7 ,8,9]]

>>> Y = [[5,8,1,2],
>>> 	[6,7,3,0],
>>> 	[4,5,9,1]]

>>> result = [[sum(a*b for a,b in zip(X_row,Y_col)) for Y_col in zip(*Y)] for X_row in X]
>>> for r in result: print(r)
	[114, 160, 60, 27]
	[74, 97, 73, 14]
	[119, 157, 112, 23]




------------------------------------

	DICTIONARIES

- Defining dictionary:
>>> <dict> = {'<key>':<object> , ...}

- Accessing elements:
>>> <dict>['key']

- Adding new elements:
>>> <dict>['key'] = <object>

- Show dict keys (object type: dict_keys):
>>> <dict>.keys()
>>> list(<dict>.keys())


- Show dict values (object type: dict_values):
>>> <dict>.values()
>>> list(<dict>.values())

- Show dict items (object type: dict_items):
>>> <dict>.items()
>>> list(<dict>.items())


------------------------------------

	TUPLES

- A tupla é imutável
- Os únicos dois métodos são count e index
- Mesmas formas de acesso e indexação de strings e lists funcionam em tuplas:

- Defining tuple;
>>> <tuple> = (<object> , ...)

- Return the index of a element:
>>> <tuple>.index(<object>)

- Count how many times a element is repeated:
>>> <tuple>.count(<object>)

- Tuple unpacking:
>>> (<elements>, ...) = <tuple>



- Defining a tuple if only one item:
>>> <tuple> = (<object>, )

------------------------------------

	FILES

- To read or write to a file, it needs to be opened. 
- When the work is done, it needs to be closed, so the resources tied with the file are freed.


- Current working directory (Jupyter):
>>> pwd

- Open a file:
>>> <file> = open('<file-path>')

- Specify the mode while opening a file.
>>> <file> = open('<file-path>', '<mode>')
>>> <file> = open('<file-path>', mode='<mode>')

Operations Mode:
r - read (default), error if the file does not exist.
w - write, creates the file if it does not exist. Overwrite if it does.
a - append, creates the file if it does not exist.
x - exclusive creation, creates the file, returns an error if the file exists.

Mode:
t - text (default)
b - binary


- When working with files in text mode, it is highly recommended to specify the encoding type.
- The default encoding is platform dependent. In Linux it is 'utf-8'. In windows, it is 'cp1252'.
- If relying on default the code will behave differently in different platforms.

>>> <file> = open('<file-path>', '<mode>', <encoding>)
>>> <file> = open('<file-path>', mode='<mode>', encoding=<encoding>)






- Read file content:
>>> <file>.read()
>>> <file>.read(<size>)

- Set cursor position:
>>> <file>.seek(<position>)
>>> <file>.seek(0)				# start of the file

- Return current cursor position:
>>> <file>.tell()

- Read file to the end of the line from cursor position:
>>> <file>.readline()

- Return a list with all lines from cursor position:
>>> <file>.readlines()


- Print each line:
>>> for line in <file>:
>>> 	print(line)





- Write to a file (this method returns the number of characters written):
>>> <file>.write('<content>')






- Close a file after it is used:
>>> <file>.close()

- If an exception occurs when performing a operation on the file, the code exits without closing it.
- Thus, a safer way to use de file is:

>>> try:
>>> 	<file> = open('<file-path>', <encoding>)
>>> 	
>>> finally:
>>> 	<file>.close()

- Or even saferer:

>>> with open('<file-path>', <encoding>) as <file>:
>>> 	<instructions>






------------------------------------

	SETS
	
- Sets só permitem valores únicos, sem repetir, e ordenados

- Defining a set:
>>> <set> = set()

- Add elements to set:
>>> <set>.add(<value>)





## Examples ##
- Get all values on a list, without repeating:
>>> l = [1,2,2,33,4,4,11,22,3,3,2]
>>> shit = list(set(l))
>>> print(shit)
	[1, 2, 33, 4, 3, 11, 22]




------------------------------------

	CODE FLOW CONTROL STRUCTURES

>>> if <boolean>:
>>> 	<instructions>
>>> elif <boolean>:
>>> 	<instructions>
>>> else:
>>> 	<instructions>


>>> <element/instruction> if <boolean> else <element/instruction>


>>> for <element> in <iterable>:
>>> 	<instructions>
# iterables: lists, dictionary keys, dictionary values, dictionary items, tuples, strings, iterators

>>> for _ in <iterable>:
>>> 	<instructions>



- For/else/break (executes the else after the loop only if it didn't find a break):

>>> for <element> in <iterable>:
>>> 	<instructions>
>>> 	if <boolean>:
>>> 		<instructions>
>>> 		break
>>> else:
>>> <instructions>



- Tuple unpacking:
>>> (<elements>, ...) = <tuple>

- Create a range-sequence of Integers:
>>> range(<excluded-stop>)							# start = 0
>>> range(<included-start>, <excluded-stop>)
>>> range(<included-start>, <excluded-stop>, <step>)




>>> while <boolean>:
>>> 	<instructions>


>>> while <boolean>:
>>> 	<instructions>
>>> else:
>>> 	<instructions>



- Stop repetition:
	
>>> while True:
>>> 	<instructions>
>>> 	if <boolean>:
>>> 		break	# works on for and while



- Stop current iteration and continue repetition:
	
>>> while <boolean>:
>>> 	<instruction>
>>> 	if <boolean>:
>>> 		continue
>>> 	<instruction>




- List comprehension:
>>> [<element/instruction> for <element> in <iterable>]
>>> [<element/instruction> for <element> in <iterable> if <boolean>]
>>> [<element/instruction> if <boolean> else <element/instruction> for <element> in <iterable>]

>>> [<element/instruction> for <element> in <iterable> for <element> in <iterable> ...]








## Examples ##

>>> range(0,10)
	range(0, 10)
>>> type(range(0,10))
	range
>>> list(range())
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




>>> x = 0
>>> while x <= 10:
>>> 	x += 1
>>> 	if (x % 2) == 1:
>>> 		continue
>>> 	print (x, 'is even')
	2 is even
	4 is even
	6 is even
	8 is even
	10 is even




>>> l = [ (1, 2), (3, 4), (5, 6) ]
>>> (um, dois) = l[0]
>>> print (dois, um)
	2 1

>>> for (um, dois) in l:
>>> 	print("%d x %d = %d" %(um,dois,um * dois))
	1 x 2 = 2
	3 x 4 = 12
	5 x 6 = 30

>>> for (key, value) in <dict>.items():
>>> 	print(key, ':', value)



- Print integers from 1 to 100, but for multiples of 3 print "Fizz" instead, for multiples of 5 print "Buzz" instead, and for multiples of both print "FizzBuzz" instead.

>>> for n in range(1,101): print('FizzBuzz') if (n%3==0 and n%5==0) else (print('Fizz') if n%3==0 else (print('Buzz') if n%5==0 else print(n)))



------------------------------------

	FUNCTIONS

- Defining simple function:
>>> def <function>():
>>> 	<instructions>

- Call function:
>>> <function>()

- Add Docstring (description) to a function:
>>> def <function>():
>>> 	"""
>>> 	<Docstring>
>>> 	"""
>>> 	<instructions>


- Function with arguments:
>>> def <function>(<args>, ...):
>>> 	<instructions>


- Return:
>>> def <function>():
>>> 	<instructions>
>>> 	return <object>







## Examples ##

>>> def isprime(num):
>>>     """
>>>     Método pra checar se é primo
>>>     """
>>> 	for ind in range(2,num):
>>>         if num%ind == 0 :
>>>             print("Not prime")
>>>             break
>>>     else:
>>>         print("Prime")
>>> isprime(104729)
	Prime




>>> def func():
>>> 	a = 1
>>> 	print(locals())

>>> sameFunc = func()
	{'a': 1}
>>> type(sameFunc)		# func() returned nothing
	NoneType
>>> sameFunc = func
>>> def otherFunc(function):
>>> 	function()
>>> otherFunc(sameFunc)
	{'a': 1}





------------------------------------

	UNPACKING

- Aka Starred Expression.

- Unpacking can be done with lists, tuples and dictionaries.

- Unpacking can be useful to use the items of a iterable as arguments for a function call requiring separate positional arguments.

- For lists and tuples it is used the '*' operator.

- For dictionaries it is used the '**' operator.





## Examples ##

>>> args = [5, 27, 3]
>>> list(range(*args))
	[5, 8, 11, 14, 17, 20, 23, 26]

>>> d = {'word':'butt' , 'l':'t'}
>>> print( ' {word} {l} {var}'.format( **d, var='shit' ))

------------------------------------

	LAMBDA

- Função definida em uma única linha.
- Função "anônima".


- Defining a lambda function:
>>> lambda <args>, ... : <instruction>


- Atributing lambda to a label:
>>> <lambda> = lambda <args>, ... : <instruction>


------------------------------------

	NESTED STATEMENTS AND SCOPE

- Scopes order:

	1- local - inside functions

	2- enclosing functions locals - on local scope of any nested functions, from insideout

	3- global - in the top level of a file or declared as global in a function

	4- built-in (python) - pre-assigned




- Return a Dictionary of global or local variables:
>>> locals()
>>> globals()

>>> locals()['<variable-label>']
>>> globals())['<variable-label>']





## Examples ##

- Locals (x):

>>> x = 'global'
>>> def func():
>>> 	x = 'local'
>>> 	print(x)

>>> print(x)
	global
>>> func()
	local






- Enclosing functions locals:

>>> def outterFunc():
>>> 	x = 'local'
>>> 	def innerFunc1():
>>> 		x = 'nested local'
>>> 		print (x)
>>> 	def innerFunc2():
>>> 		nonlocal x
>>> 		print (x)
>>> 	innerFunc1()
>>> 	innerFunc2()
>>> outterFunc()
	



>>> name = 'global'
>>> def greet():
>>> 	name = 'local'
>>> 	def hello():
>>> 		print('enclosing function '+ name)
>>> 	hello()
>>> greet()
	enclosing function local






- Global:

>>> name = 'global'
>>> def greet():
>>> 	# now without the enclosing function local
>>> 	def hello():
>>> 		print(name)
>>> 	hello()
>>> greet()
	global





>>> x = 'global'
>>> def func():
>>> 	global x
>>> 	x = 'not local, global'
>>> 	print(x)

>>> func()
	not local, global
>>> print(x)
	not local, global






------------------------------------

	OBJECT ORIENTED: CLASSES, PROPERTIES AND METHODS, INHERITANCE, SPECIAL METHODS


- Classes have a Initialization Function, aka Constructors (__init__). Used to assign values to attributes and do operations necessary when the object is being created.

- The 'self' parameter is reference to the current instance of the class. It is used to access attributes of the class. It doesn't need to be 'self', it can be whatever, but it has to be the first parameter of any function in the class.


- Create a Class:

>>> class <Class>:
>>> 	
>>> 	<attributes>
>>> 	
>>> 	def __init__(self, <parameters>, ...):
>>> 		self.<property> = <parameter>
>>> 	
>>> 	def <methods>(self, <parameters>, ...):
>>> 		<instructions>




- Create an object (instance) from a Class:

>>> <object> = <Class>()



- Call a method:

>>> <object>.<method> (<args>, ...)



- A Class can inherit attributes and methods from other class.

- A child Class can overwrite the methods inherited from the parent Class. After that, it is still possible to access the the parent's methods.



- Create a Class that inherit the properties and methods from other Class:

>>> class <Class> (<parent-Class>):
>>> 	
>>> 	<attributes>
>>> 	<__init__>
>>> 	<methods>
>>> 	
>>> 	# Overwriting a parent method:
>>> 	
>>> 	def <parente-method>(self, <parameters>, ...):
>>> 		<new-instructions>
>>> 	
>>> 		# Using a overwriten parent method:
>>> 		
>>> 		<parent-Class>.<parente-method>()





- More info on special methods: https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html
- More info on special methods: https://diveintopython3.net/special-method-names.html

- Special methods:

>>> class <Class>:
>>> 	
>>> 	# Constructor. Behavior of '<object> = <class>()'
>>> 	
>>> 	def __init__(self, <parameters>, ...):
>>> 		self.<property> = <parameter>
>>> 	
>>> 	
>>> 	# Behavior when using '<object> + <other-object>'
>>> 	
>>> 	def __add__(self, <other-object>):
>>> 		<instructions>
>>> 	
>>> 	
>>> 	# Return when used the 'len(<object>)' function
>>> 	
>>> 	def __len__(self):
>>> 		return <attribute/method>
>>> 	
>>> 	
>>> 	# Behavior of '<object>[<key>]
>>> 	
>>> 	def __getitem__(self, key):
>>> 		return <attribute/method>
>>> 	
>>> 	
>>> 	# Return when 'str(<object>)' or 'print(<object>)'
>>> 	
>>> 	def __str__(self):
>>> 		return <str>
>>> 	
>>> 	
>>> 	# Behavior when object deleted by del(<object>)
>>> 	
>>> 	def __del__(self):
>>> 		<instructions>








- Delete attributes on objects, or delete whole objects:

>>> del <object>.<attribute>

>>> del <object>





- Save object to file:
https://stackoverflow.com/questions/4529815/saving-an-object-data-persistence


------------------------------------

	ERRORS: TRY & EXCEPT

- Try code possible errors.
- In case of a specific Exception, treat as specified on the except block. If the Exception is not specified, any error will be treated.
- If none of the Exceptions occur, do 'else'.
- To Capture the error message use 'except Exception as <object>'
- The 'finally' block runs independent of  what happens ( useful in case of: a return on the except block, if a Exception is thrown in the except block, if a Exception is thrown on the try block, but is not treated on any except block in which case finally is executed before the Exception is propagated).

>>> try:
>>> 	<instructions>
>>> 	
>>> except <Exception>:
>>> 	<instructions>
>>> 	
>>> except ...
>>> 	...
>>> 	
>>> except Exception as <object>:
>>> 	<instructions>
>>> 	
>>> else:
>>> 	<instructions>
>>> 	
>>> finally:
>>> 	<instructions>




------------------------------------

	PACKAGES AND MODULES

- Some built-in libraries:
math
ramdom
os
time
pickle


- Available:
[pacman]	python-gmpy2
			Provides C-coded Python modules for fast multiple-precision arithmetic.
			(https://github.com/aleaxit/gmpy)
			(https://gmpy2.readthedocs.io/en/latest/mpfr.html)
			
[conda]		gmpy2
			GMP/MPIR, MPFR (Multiple Precision Floating-point Rounding), and MPC interface to Python 2.6+ and 3.x




(more info: https://docs.python.org/2/tutorial/modules.html#packages)
(See 'if __name__ == "__main__"' firefox-bookmark for more info)

- A directory with a file '__init__.py' can be called a Package, and the files within are seen by Python as Modules.
- If a package has a '__init__.py', once it is imported, this file is executed. Also, it will have "priority", meaning it wont search the module on other paths with same name.
- If it doesn't has '__init__.py', is is trea as a namespace package (?), and will search the module on the current folder and on python's path.


<project>/
|
|	<main>.py
|	<module>.py
|	
|	<package>/
|	|
|	|	__init__.py
|	|	<module>.py
|	|	...
|	|	
|	|	<sub-package>/
|	|	|
|	|	|	__init__.py
|	|	|	<module>.py
|	|	|	...
|	|	|
|	|
|





- Import:
>>> import <module>
>>> import .<module>
>>> import <package>.<module>
>>> import <package>.<sub-package>.<module>

>>> import <module> as <name>

>>> from <package>.<module> import <function>
>>> from <package>.<sub-package>.<module> import <function>







	(basically, never use pip)
	(conda on Virtual Enviroment)
	(pacman on the system)

	WARNING: NEVER run 'pip install <module>' on the TERMINAL. You should never make any changes to '/usr', except through pacman. If you need to install with pip do it in a Virtual Enviroment (like conda).

	(if a package isn't available by conda, try conda-forge before even thinking on pip)
	(https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages)


- Install packages on current env:
(<env>)$ conda install <package>
(<env>)$ conda install <package>=<version>

- Install packages on other env:
$ conda install <package> -n <env>

- Search package:
$ conda search <package>

- Search package info:
$ conda search <package> --info

- List installed package:
$ conda list
$ conda list <package>


- Check available updates:
$ conda update

- Update a package:
$ conda update <package>
$ conda update python
$ conda update conda
$ conda update anaconda

- Remove a packages:
(<env>)$ conda install <package>
$ conda install <package> -n <env>







- Display where Python looks for modules:
>>> import sys
>>> type(sys.path)
	list
>>> print('\n'.join(sys.path))


- Add directory temporarily to the 'sys.path' list, to be seen as a package:
>>> import sys
>>> sys.path.append('<absolute-path>')


- Add directory permanently to 'sys.path':
Using PYTHONPATH: (https://bic-berkeley.github.io/psych-214-fall-2016/using_pythonpath.html)
Making a Python Package: (https://packaging.python.org/tutorials/packaging-projects/)


- Find where a molude is:

>>> import <module>
>>> <module>.__file__

>>> import imp
>>> imp.find_module('<module>')

(The '__file__' attribute is not present for C modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file.)












## Examples ##



'__init__.py'
>>>

'<main>.py'
>>> from <package>.<module> import <function>






'__init__.py'
>>> from .<module> import *

'<main>.py'
>>> from <package> import <function>





>>> import os
>>> clear = lambda: os.system('clear')





- Importing a function:
>>> import os
>>> cwd = os.getcwd()								# currently working directory
>>> os.chdir("<directory-of-the-function-file>")	# REMEMBER TO USE UNDERSCORE (_) INSTEAD OF HIFEN (-) ON FILES YOU GONNA IMPORT FROM
>>> from <file> import <function>

>>> os.chdir(cwd)



------------------------------------

	SOME BUILT-IN FUNCTIONS

- MAP
- Aply a function to all of a iterable's elements.
- Returns a memory instruction (map type object).
- Don't use the paranthesis on the function.
- You can define a lambda right on the map() argument.

>>> map(<function>, <iterable>)

>>> list(map(<function>, <iterable>))





- REDUCE
- Aply a function to all of a iterable's elements, two by two.
- Initially the first two, and then, it's result and the next from the iterable.
- Goes until it is reduced to a single element which is returned.

>>> from functools import reduce	# Python 3
>>> reduce(<function>, <iterable>)





- FILTER
- Uses a filter function (with boolean return) to exclude items in an iterable object
- Returns a memory instruction (filter type object).

>>> filter(<function>, <iterable>)





- ZIP
- Returns an iterable of tuples from two or more iterables.
- Each item with the same index from each iterable is paired together in a tuple.
- If the iterables have different lengths, the zip has the size of the smaller one.
- Returns a memory instruction (zip type object).

>>> zip(<iterable-1>, <iterable-2>, ...)





- ENUMERATE
- Takes a collection (iterable) and adds a counter as key in a tuple with each item.
- By default stars the counter from 0.
- Returns a memory instruction (enumerate type object).

>>> enumerate(<iterable>)
>>> enumerate(<iterable>, <start>)





- ALL & ANY
- Returns True if (all or any) items in an iterable object are true.
- If the iterable is empty, all() returns True and any() False.

>>> all(<iterable>)

>>> any(<iterable>)





## Examples ##

>>> celsius = [0, 9, 10, 15, 20, 22, 30, 40, 50, 90, 100, 120]
>>> fahrenheit = list(map(lambda temp: temp * (9/5) + 32, celsius))
	[32.0, 48.2, 50.0, 59.0, 68.0, 71.6, 86.0, 104.0, 122.0, 194.0, 212.0, 248.0]



>>> from functools import reduce
>>> values = [47, 11, 42, 13]
>>> biggest = reduce( (lambda a,b: a if a>b else b) , values )
	47



>>> ages = [5, 12, 17, 18, 24, 32]
>>> underage = list(filter( (lambda ag: False if x>18 else True) , ages))
	[5, 12, 17]



>>> uCase = ['A', 'B', 'C']
>>> lCase = ['a', 'b', 'c']
>>> nums = (1, 2, 3, 4, 5)
>>> list(zip(uCase, lCase, nums))
	[('A', 'a', 1), ('B', 'b', 2), ('C', 'c', 3)]








------------------------------------

	DECORATORS & CLOSURE

- Make a Function that add other functionalities (Decorate) to a (existing or new) function:

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( <parameters> ):
>>> 		<instructions>
>>> 		return <in-func>( <parameters> )
>>> 	
>>> 	return <out-func>

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( <parameters> ):
>>> 		<instructions>
>>> 		<in-func>( <parameters> )
>>> 		<instructions>
>>> 	
>>> 	return <out-func>





- Decorate (existing or new, respectively):

>>> <new-func> = <decorator> (<func>)

>>> @<decorator>
>>> def <func> ():
>>> 	<instructions>


- Multiple decorators can be chained:

>>> <new-func> = <decorator1> ( <decorator2> ( ... (<func>)))

>>> @<decorator1>
>>> @<decorator2>
>>> ...
>>> def <func> ():
>>> 	<instructions>





- Make general decorators that work with any number of parameters.
- 'args' will be the tuple of positional arguments
- 'kwargs' will be the dictionary of keyword arguments

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( *args, **kwargs ):
>>> 		<instructions>
>>> 		return <in-func>( *args, **kwargs )
>>> 	
>>> 	return <out-func>

>>> def <decorator> (<in-func>):
>>> 
>>> 	def <out-func>( *args, **kwargs ):
>>> 		<instructions>
>>> 		<in-func>( *args, **kwargs )
>>> 		<instructions>
>>> 	
>>> 	return <out-func>





- Get some data attached (Closure) to a function.
- By using this, once defined, the function will hold a "hidden" data.
- Can be used to create objects storing data withou the need to make a Class.

>>> def <closure>( <variables> ):
>>> 
>>> 	def <out-func>():
>>> 		<instructions>( <variables> )
>>> 	
>>> 	return <out-func>

>>> <func> = <closure>( <data> )





- Accessing Enclosed Values.
- Enclosed function objects have '__closure__' attribute with tuple of cell objects.
- The cell object has the attribute 'cell_contents' which stores the closed value.

>>> <enclosed-func>.__closure__

>>> <enclosed-func>.__closure__[<index>].cell_contents







## Examples ##

>>> def make_multiplier(n):
>>> 	
>>> 	def multiplier(x):
>>> 		return x * n
>>> 	
>>> 	return multiplier

>>> times3 = make_multiplier(3)
>>> times3(9)
	27

>>> times5 = make_multiplier(5)
>>> times5(9)
	45

>>> def addExplaning(func):
>>> 	
>>> 	def outFunc(x):
>>> 		print("I'm a function that multiplies %d by the given number %d:" %( func.__closure__[0].cell_contents, x))
>>> 		return func(x)
>>> 	
>>> 	return outFunc
>>> 
>>> times5 = addExplaning(times5)
>>> print(times5(9))
	I'm a function that multiplies 5 by the given number 9:
	45


------------------------------------

	ITERATORS & GENERATORS

- A Python Iterator Object must implement the methods '__iter__()' and '__next__()' (iterator protocol).
- The 'next()' and 'iter()' functions call the '__next__()' and '__iter__()' methods.
- The 'next()' function manually iterate through all the items.
- When reachs the end raises the 'StopIteration' Exception.
- The 'iter()' function returns an iterator from a object.

>>> <iterator> = iter(<iterable>)

>>> next (<iterator>)

>>> class <custom-iterator>:
>>> 	
>>> 	def __init___(self, max=0):
>>> 		self.n = 0
>>> 		self.max = max
>>> 	
>>> 	def __iter__(self):
>>> 		return self
>>> 	
>>> 	def __next__(self):
>>> 		if self.n > self.max:
>>> 			raise StopIteration
>>> 		
>>> 		<instruction>
>>> 		self.n += 1
>>> 		return <value>
>>> 
>>> <obj> = <custom-iterator>(<max>)
>>> <iterator> = iter(<obj>)





- Function that generates and returns a iterator.
- When called, returns a iterator object, but does not start execution immediately.
- Mehods '__iter__()' and '__next__()' are implemented automatically.
- Local variables are not destroyed when the function yields.
- The generator object can be iterated only once.
- Can be used to represent an infinite stream of data.

>>> def <gerenator>():
>>> 	<instructions>
>>> 	yield <value>

>>> <iterator> = <gerenator>()

>>> next (<iterator>)





- Gerenator Expression.
- Much more memory efficient than an equivalent list comprehension.

>>> (<element/instruction> for <element> in <iterable>)
>>> (<element/instruction> for <element> in <iterable> if <boolean>)
>>> (<element/instruction> if <boolean> else <element/instruction> for <element> in <iterable>)





## Examples ##

>>> def PowTwo(max=0):
>>> 	n = 0
>>> 	
>>> 	while n < max:
>>> 		yield 2 ** n
>>> 		n += 1

>>> numbers = PowTwo(3)		# object
>>> i = iter(numbers)		# iterator

>>> for i in PowTwo(3):
>>> 	print(i, end=' ')
	1 2 4 8 


# Sum of the squares of the numbers in the Fibonacci Sequence
>>> def fibonacci_numbers(nums):
>>> 	x, y = 0, 1
>>> 	for _ in range(nums):
>>> 		x, y = y, x+y
>>> 		yield x
>>> 
>>> def square(nums):
>>> 	for num in nums:
>>> 		yield num**2
>>> 
>>> print(sum(square(fibonacci_numbers(100))))
	203023208030065646654504166904697594722575

	
------------------------------------

	DEBUGGING

- Evaluate a boolean and throw a 'AssertionError' (and message) if False:

>>> assert <boolean>

>>> assert <boolean>, <str-message>


------------------------------------







------------------------------------

	TITTLE

- 

------------------------------------



------------------------------------



------------------------------------



------------------------------------



------------------------------------




------------------------------------



------------------------------------



------------------------------------



------------------------------------



------------------------------------




#
#

#
#   -----------------------------------------
#   RESERVED WORDS
#
False
None
True
and
as
assert
break
class
if
def
del
elif
else
except
return
for
from
global
try
import
in
is
lambda
while
not
or
pass
raise
finally
continue
nonlocal
with
yield
#
#   -----------------------------------------
#   MATRIX
>>>

inf = float('inf')

A = [[0,1,4,inf,3],
     [1,0,2,inf,4],
     [4,2,0,1,5],
     [inf,inf,1,0,3],
     [3,4,5,3,0]]

def printmat(A,space=4):

    print('\n'.join([''.join(['{{:{}}}'.format(str(space)).format(item) for item in row]) for row in A]))
    return

printmat(A,5)

#
#   -----------------------------------------
#   EDX EXAMPLE:
>>>

name = input('Enter file: ')
handle = option(name)

counts = dict()
for line in handle:
    words = line.split()
    for word in words:
        counts[word] = counts.get(word,0) + 1

bigcount = None
bigword = None
for word,count in counts.items():
    if bigcount is None or count > bigcount:
        bigword = word
        bigcount = count

print(bigword, bigcount)

#
#
#   -----------------------------------------
#	EXAMPLE
#
#   Remove all items in Python list containing a number [duplicate]
#
#

foo = ['This', 'That', 'Those4423', '42', '13b', 'Yes', '2']

foo1 = [x for x in foo if not any(x1.isdigit() for x1 in x)]

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

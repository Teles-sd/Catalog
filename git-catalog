
		GIT

------------------------------------

	MY TERMINOLOGY

$	: Some command to be used on the Terminal (shell).

<description>	: Something to be replaced according to the description.
...				: Possible to repeated pattern indefinitely.

------------------------------------

	HELP

- Help and Manuals:
$ git help
$ git help <command>
$ man git-<command>

- Official Glossary (confusing a.f.):
$ man gitglossary
$ git help gitglossary

- More info on spell Commits:
$ man gitrevisions
$ git help gitrevisions

url: (https://git-scm.com/docs)

------------------------------------

	GLOSSARY

- Repository (aka. Local Repository):
	A Git Repository is the '.git/' directory inside a project, containing all the necessary repository files.

- Work-tree (aka. Working-tree, Workspace, Working Directory):
	Place where the files of a project's Repository are.

- Path component:
	Directories and subdirectories inside the Work-tree that lead to a file.

- Path-name:
	Any file inside the Commits (inside the Repository) have a Path-name.
	The Path name is all the Path components from the Top level to where this file is in the Work-tree.
	Never start with slash.
	As: "path/to/file".

- Top level:
	The path on the machine to the Work-tree.

- Index (aka. Staging Area):
	Where the files from the project that will be commited are placed.
	"Staged Files" are files tracked in the Index and staged to commit.
	"Not Staged Files" are files tracked in the Index but not staged.
	"Untracked Files" are the ones not added to the Index .
	Files can be added and removed from Index at will, before commiting.

- Commit (aka. Revision):
	Record of changes to the Repository's files.
	Commits usually contain a brief message/description.
	Each Commit creates a ID (aka. hash or SHA) to keep record of what changed, when and by who.

- Refname:
	Reference to a specific Commit.

- Branch:
	A succession of Commits on the project.
	An active Line of development.
	A Git Repository can have any number of Branches.

- HEAD (aka. tip of that Branch):
	Points to the last Commit to the current Branch.

- Clean Work-tree:
	When a Working-tree corresponds to the current HEAD, i.e. all it's modifications have been committed to the current Branch.

- Dirty Work-tree:
	When a Work-tree contains modifications which have not been committed to the current Branch.

- Remote (aka. Remote Repository, Upstream Repository):
	A Repository to track the project, but residing somewhere else.

- Fetch:
	Get a Branches’s head ref from a Remote repository.
	To find out which objects are missing from the local Repository.

- Push:
	Updating a Remote Branch with a local Branch's content.
	If the Remote head is not ancestor to the local head, the push fails.

- Merge:
	Incorporate, on current Branch, changes from other Branch's commit since the time their histories diverged.
	Records the result in a new commit.

- Rebase:
	Incorporate on current Branch changes from other Branch's commit by rewriting the Commit history, producing a linear succession of commits.
	Takes each Commit of the rebased Branch and roduces a linear succession of new Commits.

- Nested repository:
	A Repository (and Work-tree) that is in another Repository's Work-tree.
	Git don't store files or directories with a '.git/' Path componet.
	Thus, a Repository don't store another Repositories within it.
	You can create a Git Repository within the Work-tree of another Git repository, but you can't add and commit it to the other.

- Submodules:
	A Git Repository that is refered to in another Git Repository.



------------------------------------

	QUICK START (BASICS)

- Create a local Repository:
$ cd <path>
$ git init

- Add a Remote (previously created on the Github website):
$ git remote add <name> <url>
$ git remote add origin https://github.com/<user>/<repo>

- Display Remotes:
$ git remote -v

- Update Branches seen from Remote:
$ git fetch <remote>

- Fetch and Merge Branch from a Remote:
$ git pull <remote> <branch>
$ git pull origin master

- Add all files from the Work-tree to Index:
$ git add .

- Display updates to the Index:
$ git status

- Commit contents of Index to current Branch, with a log message:
$ git commit -m '<log-message>'

- List local Branches in Repository:
$ git branch

- List Remote Branches:
$ git branch -r

- List all Branches:
$ git branch -a

- Update a Remote Branch with the current Branch's contents (same name Branches):
$ git push <remote> <branch>
$ git push origin master


------------------------------------

	WORK-TREE, INDEX & COMMITS


WORK-TREE -> INDEX

- Display current Branch and Index (staged and untracked files):
$ git status

- List all file from Index AND Work-tree:
$ git ls-files

- Add specific file (or files) from the Work-tree to Index:
$ git add <file>
$ git add <file> ... <file>

- Add all files from the Work-tree to Index:
$ git add .

- Updated tracked (in Index) files from Working-tree to Index:
$ git add -u
$ git add --update

- Remove file from Work-tree and Index:
$ git rm <file>

- Move file on Work-tree and Index:
$ git mv <file> <destination>




INDEX -> REVISION

- It is a good practice (that I don´t have) to not mix different topics in the same commit.

- Commit contents of Index to current Branch, with a log message:
$ git commit -m '<log-message>'

- DON'T Commit. Show summary of what's included on next commit:
$ git commit --dry-run

- Commit only changes made on a specific Path-name (ignore Index):
$ git commit <path-name>

- Update the last commit by adding the currently staged changes:
$ git commit --amend

- Amend HEAD, suppress Editor´s opening:
$ git commit --amend --no-edit

- Commit contents of Index and further edit the message (open Editor):
$ git commit -m '<log-message>' --edit


------------------------------------

	LOG

LOG

- Follow chronological order.

- Display Commit history from current Branch:
$ git log --oneline
$ git log

- Limit the number of commits to output:
$ git log -n <number>
$ git log -<number>
$ git log --max-count=<number>

- Show only Commits done on the current Branch (excluding Commits done on other Branches before Merging):
$ git log --first-parent

- "Pretty" Log:
$ git log --pretty="format:%h %ar %s"





GRAPH

- Follows topological ordering, not chronological order.

- Display a log graph for the Commits and Merges:
$ git log --graph

- Display compact graph of all Branches:
$ git log --graph --oneline --all






REFLOG

- Log changes on the HEAD pointer.
- Records updates to the tip of the Branch, switches, ammends, resets...

- Show Reflog:
$ git reflog


------------------------------------

	BRANCHES


- Create a new Branch from current HEAD:
$ git branch <branch>

- Create a new Branch from previous commit:
$ git branch <branch> <commit>



- List local Branches in Repository:
$ git branch
$ git branch -l
$ git branch -l '<pattern>'
$ git branch --list

- List Remote Branches:
$ git branch -r
$ git branch -rl '<pattern>'
$ git branch --remotes

- List all Branches:
$ git branch -a
$ git branch -al '<pattern>'
$ git branch --all



- Rename Branch:
$ git branch -m <branch> <new-name>
$ git branch --move <branch> <new-name>



- Switching Branch updates Index and Work-tree.
- Does not require a clean index and working tree.
- The operation is aborted if leads to loss of local changes.
- Recommended Commit or Stash before switching.

- Switch Branch:
$ git switch <branch>



- Delete Branch:
$ git branch -d <branch>

- Delete Branch even if current Branch doesn't have all commits from it:
$ git branch -D <branch>

- Recover a deleted branch:
$ git reflog
$ git branch <branch> <commit>


------------------------------------

	SPELL COMMITS (REFNAME OR REFSPEC)

- Refname: How to refer to a specific Commit.


- By SHA-1:
	
	- The full SHA-1 object name (40-byte hexadecimal string), or it's short version (a leading substring that is unique within the Repository).
	
	- See it's short version with:
	$ git log --oneline
	
	- Or, it's full version with:
	$ git log



- Refnames:
	
	HEAD             - last Commit of current Branch
	<branch-name>    - will refer to a Branch's HEAD
	FETCH_HEAD       - last Commit of Branch fetched from Remote.
	ORIG_HEAD        - records Commit before operations that move HEAD in drastic way.
	                   Eg. 'git merge'.
	MERGE_HEAD       - records Commit of Branch that merges into current Branch.
	CHERRY_PICK_HEAD - records the Commit of 'git cherry-pick'.



- Refnames for prior Commits:
	
	<commit>^<n>
	<branch>^{<n>}
		
		A Commit might have multiple parent in case of merge.
		A Commit with the suffix '^' and a number (n) refers the n-th parent of that Commit.
		
		DOES NOT Follow chronological order.
		Goes as in 'git log --graph'.
		
		'<commit>^' is equivalent to '<commit>^1'
	
	
	<commit>~<n>
	<branch>~{<n>}
		
		A Commit with the suffix '~' and a number (n) refers the n-th ancestor of that Commit, following only the first parents (ORIG_HEAD).
		
		DOES NOT Follow chronological order.
		Goes as in 'git log --graph'.
		
		'<commit>~' is equivalent to '<commit>~1'
		'<commit>~3' is equivalent to '<commit>^^^',
		                equivalent to '<commit>^1^1^1',
		                but NOT '<commit>^3'.
	
	
	Example:
	Consider this Branch:
	- Commit F recieves a Commit and becomes E.
	- Commit E recieves a Commit and becomes B.
	- Commit B merges C and D; and becomes A.
	
	
	F--E--B--A
	       / |
	... --C /
	       /
	... --D
	
	
	
	A---.
	| \  \
	B  C  D
	|
	E
	|
	F
	
	
	In this case:
	
	A~1 = B
	A~2 = E
	A~3 = F		= A^^^ = A^1^1^1
	
	A^1 = B		= A^
	A^2 = C
	A^3 = D
	
	
	<commit>@{<n>}
		
		A Commit with the suffix '@' and a number (n) refers the n-th prior Commit of that ref.
		If no Commit is given, considers current Branch's HEAD.
		
		Follows chronological order as in 'git log'.
	


- More info on spell Commits:
$ man gitrevisions
$ git help gitrevisions



------------------------------------

	DIFFS

- All the following commands can be used with a external tool using:
$ git difftool


- View changes in Work-tree, relative to a Commit:
$ git diff <commit>
$ git diff HEAD
$ git diff --name-only <commit>

- View changes in a specific file, relative to a Commit:
$ git diff <commit> <file>
$ git diff HEAD <file>
$ git diff --name-only <commit> <file>




- View changes Between Commits:
$ git diff <commit>..<commit>
$ git diff --name-only <commit>..<commit>

- View changes Between Commits on Github:
url: (https://github.com/<user>/<repo>/compare/<commit>..<commit>)




- View changes in Work-tree relative to the tip of another Branch:
$ git diff <branch>

- View changes in Work-tree relative to the tip of Remote Branch:
$ git fetch <remote>
$ git diff FETCH_HEAD


------------------------------------

	MERGE & REBASE

!!! WARNING:
	Running ´git merge´ or ´git rebase´ with uncommitted changes (Dirty Work-tree) is highly discouraged.

!!! WARNING:
	Never ´git rebase´ a public Branch.
	Also, avoid rebasing the master Branch.




MERGE

- Incorporate, on current Branch, changes from other Branch's commit.
- Records the result in a new commit.


- Merge other Branch's HEAD into current Branch:
$ git merge <branch>
$ git merge <branch> -m '<log-message>'

- Merge other Branch's commit into current Branch:
$ git merge <commit>
$ git merge <commit> -m '<log-message>'

- If (and only if) the merge has resulted in conflicts, the following commands are available:
$ git mergetool
$ git merge --continue
$ git merge --abort
$ git merge --quit




REBASE

- Incorporate on current Branch changes from other Branch's commit.
- Does this by rewriting the Commit history.
- Takes each Commit of the rebased Branch and creates a linear succession of new Commits.

- Rebase can also be done from the own Branch´s past Commit.
- This is done to Rewrite history.


- Rebase current Branch starting on other Branch´s HEAD:
$ git rebase <branch>
$ git rebase -i <branch>

- Rebase current Branch starting on a previous Commit:
$ git rebase <commit>



- Interactive Rebase.
- The next file that will open is only to say to git what it´s gonna do.
- In this file, Commits can be re-ordered and more.
- Every command needs to be specified:
	# pick   <commit> = use commit
	# reword <commit> = use commit, but edit the commit message
	# edit   <commit> = use commit, but stop for amending
	# squash <commit> = use commit, but combine into previous commit
	# drop   <commit> = remove commit
- Save and close.
- ONLY after this make the changes.

- Interactive Rebase current Branch starting on a previous Commit:
$ git rebase -i <commit>

- If you use the ´edit´ command, after you´re done, use:
$ git rebase --continue

- Add change to old Commits:
$ git commit --fixup <wrong-commit>
$ git rebase -i --autosquash <wrong-commit>~1 


------------------------------------

	UNDO MISTAKES



AMEND (PREVIOUS COMMIT)

!!! WARNING: Never change history of public commits!

- Replace the HEAD by creating a new commit with the current Index:
$ git commit --amend

- Amend HEAD with new message:
$ git commit --amend -m "<log-message>"

- Amend HEAD, suppress Editor´s opening:
$ git commit --amend --no-edit

- Automatically stage files:
$ git commit --amend -a
$ git commit --amend --all

- Get a summary without Commiting:
$ git commit --amend --dry-run

- Fix identity of previous commit:
$ git commit --amend --reset-author







STASH

- Hides modifications (making the Work-Tree clean) to work on something else.
- After saving the Stash, Resets Work-Tree and Index.


- Save local modifications to a new Stash:
$ git stash
$ git stash <log-message>

- Create a Stash entry and return its object name, without storing it (only useful for scripts):
$ git stash create

- List the Stashes you have:
$ git stash list
$ git stash list --oneline

- Show changes between Stash and it´s parent:
$ git stash show
$ git stash show --name-only
$ git stash show <stash>

- Apply Stash (default: last one) on top of current Work-Tree, and delete it:
$ git stash pop
$ git stash pop <stash>

- If stash-pop or stash-apply results in conflicts, you have to resolve them manually. - You can use a external merge tool:
$ git mergetool

- Apply last Stash on top of current Work-Tree, without deleting the Stash:
$ git stash apply
$ git stash apply <stash>

- Remova a Stash from the Stash-list:
$ git stash drop
$ git stash drop <stash>

- Remova ALL Stashes from the Stash-list:
$ git stash clear






RESTORE (FILES)

- Restore the previous state of a file.
- Or restore deleted files.

!!! WARNING: Discarting uncommitted local changes cannot be undone.


- Restore a File to Work-tree, from Index (default):
$ git restore <file>
$ git restore -W <file>
$ git restore --worktree <file>

- Restore just a hunk of changes in a file (interactive):
$ git restore -p <file>
$ git restore --patch <file>

- Discart ALL local changes (leave Work-Tree clean):
$ git restore .

- Restore a File to the Index (from HEAD):
$ git restore -S <file>
$ git restore --staged <file>

- Restore a File to Index and Work-tree (from HEAD):
$ git restore -SW <file>

- Restore to from a previous Commit:
$ git restore --source <commit> <file>
$ git restore --source <commit> -WS <file>





RESET (INDEX)

!!! WARNING:  When Reseting to a Commit older than HEAD, deletes Commits after it.

- Reset Index (not Working-tree) to current HEAD (default):
$ git reset
$ git reset --mixed

- Reset Index AND Work-tree to a previous Commit HEAD (default=HEAD):
$ git reset --hard <commit>

- Reset current HEAD (not Index, nor Working-tree) to a previous Commit:
$ git reset --soft <commit>




REVERT (COMMITS)

- Creates a new Commit that Reverts changes of a previous Commit without deleting it.
- Requieres Clean Work-Tree.

- Reverting the HEAD to a previous Commit:
$ git revert <commit>






MISC

- Moving commit to NEW Branch to avoid commiting on master:
$ git reflog
$ git branch <branch> <commit>
$ git switch master
$ reset --hard HEAD~1





- Commits on wrong Branch:
$ git reset --soft HEAD~<n>
$ git switch <branch>
$ git add .
$ git status
$ git commit -m "<log-message>"

- Or:
$ git log --oneline             # write the hash of the one you wanna keep
$ git reset --hard HEAD~<n>
$ git switch <branch>
$ git reset --hard <commit>

- Or:
$ git reset HEAD~<n>
$ git stash
$ git switch <branch>
$ git stash pop
$ git add .
$ git status
$ git commit -m "<log-message>"





- Change Author of older Commits:
$ git rebase -i <commit>

- Change command on the Commit from ´pick´ to ´edit´. Then:
$ git commit --amend --author="<name> <<email>>" --no-edit
$ git commit --amend --reset-author --no-edit
$ git rebase --continue








------------------------------------

	REMOTES (GITHUB)


- Previously create a Remote Repository on Github website.

- If the Repository is a existent on-going project, don't initialize with README file to avoid errors on push.



- Add a Remote to Local Repository:
$ git remote add <name> <url>
$ git remote add origin https://github.com/<user>/<repo>

- Display Remotes:
$ git remote
$ git remote -v

- Rename a Remote:
$ git remote rename <remote> <new-name>

- Remove Remote:
$ git remote remove <remote>
$ git remote rm <remote>




- Delete an Upstream Branch:
$ git branch -rd <remote>/<branch>




- Update Branches seen from Remote:
$ git fetch <remote>

- Fetch and Merge Branch from Remote Branch:
$ git pull <remote> <branch>
$ git pull origin master




- Push to a Remote Branch (must be same name Branches):
$ git push <remote> <branch>

- Push from a Branch to Another Branch:
$ git push <remote> <source_branch>:<destine_branch>


!!! WARNING:
	Usually git refuses to update a Remote Branch that is not an ancestor of the local.
	This can happen in cases the history is rewritten.
	The flag '--force' disables these checks, and can cause the Remote to lose commits.
	Use it with care.

- Force Push to Remote Branch:
$ git push <remote> <branch> --force




- Download Repository a Remote (master branch):
$ git clone <url>

- Download a specific Branch from a Remote:
$ git clone -b <branch> <url>



------------------------------------

	CONFIGS


- Check personal configurations:
$ git config --list

- Reset some configuration:
$ git config --global --unset-all <config>
$ git config --unset-all <config>



IDENTITY (AUTHOR OF COMMITS)

- Configure Global user name and e-mail:
$ git config --global user.name "<name>"
$ git config --global user.email <email>

- Configure user name and e-mail for a specific repo:
$ cd <path-to-repo>
$ git config user.name "<name>"
$ git config user.email <email>

- Fix identity of previous commit:
$ git commit --amend --reset-author




TOOLS

- Note: other editors than Vim, Nano, Emacs..., might need other configurations.

- Configure Global default text editor:
$ git config --global core.editor <text-editor>
$ git config --global core.editor vim
$ git config --global core.editor nano
$ git config --global core.editor 'kate -b'




- Configure diff tool:
$ git config --global diff.tool <diff-tool>

- Configure Merge conflict diff tool:
$ git config --global merge.tool <diff-tool>


-For Meld:
$ git config --global diff.tool meld
$ git config --global difftool.prompt false

$ git config --global merge.tool meld
$ git config --global mergetool.prompt false







CREDENTIALS CACHE

- Store password on cache (default: 15 min):
$ git config --global credential.helper cache

- Display time limit of credentials cache:
$ git config --global credential.helper

- Change time limit of credentials cache ('time' in seconds):
$ git config --global credential.helper 'cache --timeout=<time>'

- More info on cache credentials:
url: (https://docs.github.com/en/github/using-git/caching-your-github-credentials-in-git)




- Using the package 'libsecret' to store credentials PERMANENTLY:
(on Arch)
$ git config --global credential.helper /usr/lib/git-core/git-credential-libsecret

(on Fedora, install 'git-credential-libsecret')
$ git config --global credential.helper /usr/libexec/git-core/git-credential-libsecret

(on Ubuntu)
$ cd /usr/share/git/credential/libsecret
$ sudo make
$ git config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret





------------------------------------




------------------------------------



(https://ndpsoftware.com/git-cheatsheet.html#loc=workspace;)


------------------------------------

